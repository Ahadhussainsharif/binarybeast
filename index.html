<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BINARY BEAST PRO 2.0 | AI-Powered Signals</title>
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=Space+Grotesk:wght@400;500;700&family=Syncopate:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --primary-dark: #0a061e;
            --primary: #13103d;
            --secondary: #241c6d;
            --accent-primary: #7e1dff;
            --accent-secondary: #11cefb;
            --accent-tertiary: #fd3aff;
            --success: #00ffc3;
            --danger: #ff2976;
            --warning: #ffc137;
            --text: #f3f0ff;
            --text-secondary: #c4c0d4;
            --panel: rgba(23, 19, 70, 0.7);
            --panel-dark: rgba(10, 6, 30, 0.85);
            --border: 1px solid rgba(126, 29, 255, 0.3);
            --border-light: 1px solid rgba(17, 206, 251, 0.2);
            --glow-primary: 0 0 25px rgba(126, 29, 255, 0.4);
            --glow-secondary: 0 0 25px rgba(17, 206, 251, 0.4);
            --radius-sm: 8px;
            --radius: 16px;
            --radius-lg: 24px;
            --transition: all 0.35s cubic-bezier(0.17, 0.67, 0.45, 0.99);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Space Grotesk', sans-serif;
        }

        body {
            background-color: var(--primary-dark);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
            background-image: 
                radial-gradient(circle at 10% 15%, rgba(126, 29, 255, 0.08) 0%, transparent 30%),
                radial-gradient(circle at 90% 85%, rgba(17, 206, 251, 0.07) 0%, transparent 35%),
                radial-gradient(circle at 50% 50%, rgba(253, 58, 255, 0.04) 0%, transparent 45%);
        }

        .container {
            width: 100%;
            max-width: 500px;
            position: relative;
            z-index: 1;
        }

        .card {
            background: var(--panel);
            border-radius: var(--radius-lg);
            overflow: hidden;
            position: relative;
            backdrop-filter: blur(10px);
            border: var(--border);
            box-shadow: var(--glow-primary);
            margin-bottom: 25px;
        }

        .card::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
            opacity: 0.8;
            z-index: 2;
        }

        .header {
            position: relative;
            background: linear-gradient(135deg, rgba(19, 16, 61, 0.9), rgba(36, 28, 109, 0.8));
            padding: 30px 20px;
            text-align: center;
            border-bottom: var(--border);
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(126, 29, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(17, 206, 251, 0.1) 0%, transparent 50%);
            z-index: 0;
        }

        .header-content {
            position: relative;
            z-index: 1;
        }

        .logo-text {
            font-family: 'Syncopate', sans-serif;
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 10px;
            position: relative;
            display: inline-block;
        }

        .logo-text span {
            display: inline-block;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
        }

        .logo-text::after {
            content: '';
            position: absolute;
            left: -5%;
            bottom: -8px;
            width: 110%;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 10px;
        }

        .tagline {
            font-size: 15px;
            opacity: 0.8;
            font-weight: 400;
            margin-top: 15px;
        }

        .content {
            padding: 30px 25px;
        }

        /* Status Bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--panel-dark);
            border-radius: var(--radius);
            padding: 16px 20px;
            margin-bottom: 25px;
            border: var(--border-light);
            position: relative;
            overflow: hidden;
        }

        .status-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(17, 206, 251, 0.05), transparent);
            z-index: 0;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            z-index: 1;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            background-color: var(--success);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--success);
            position: relative;
        }

        .status-dot::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }
            70% {
                transform: scale(2);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        .status-text {
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .status-countdown {
            font-family: 'Chakra Petch', sans-serif;
            font-weight: 600;
            color: var(--accent-secondary);
            position: relative;
            z-index: 1;
        }

        /* Platform Selection */
        .section-title {
            font-family: 'Chakra Petch', sans-serif;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--accent-secondary);
            letter-spacing: 1px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .platform-selection {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 30px;
        }

        .platform-btn {
            position: relative;
            background: rgba(19, 16, 61, 0.7);
            border: 1px solid rgba(126, 29, 255, 0.2);
            border-radius: var(--radius);
            padding: 16px 12px;
            color: var(--text-secondary);
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .platform-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, transparent, rgba(126, 29, 255, 0.1), transparent);
            z-index: 0;
            opacity: 0;
            transition: var(--transition);
        }

        .platform-btn:hover::before {
            opacity: 1;
        }

        .platform-btn.active {
            background: rgba(36, 28, 109, 0.7);
            border: 1px solid rgba(126, 29, 255, 0.5);
            color: var(--text);
            box-shadow: 0 5px 15px rgba(126, 29, 255, 0.15);
        }

        .platform-btn.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 15%;
            width: 70%;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            border-radius: var(--radius-sm);
        }

        .platform-icon {
            font-size: 24px;
            margin-bottom: 5px;
            position: relative;
            z-index: 1;
            transition: var(--transition);
        }

        .platform-btn.active .platform-icon {
            color: var(--accent-secondary);
            transform: translateY(-3px) scale(1.1);
        }

        .platform-name {
            font-weight: 600;
            position: relative;
            z-index: 1;
        }

        /* Access Code Form */
        .input-group {
            position: relative;
            margin-bottom: 25px;
        }

        .input-label {
            position: absolute;
            top: -10px;
            left: 20px;
            background: var(--panel);
            padding: 0 10px;
            font-size: 13px;
            color: var(--accent-secondary);
            font-weight: 500;
            z-index: 1;
        }

        .input-field {
            width: 100%;
            padding: 18px 20px;
            border-radius: var(--radius);
            background: rgba(10, 6, 30, 0.6);
            border: var(--border);
            color: var(--text);
            font-size: 16px;
            transition: var(--transition);
            letter-spacing: 0.5px;
        }

        .input-field:focus {
            outline: none;
            box-shadow: var(--glow-primary);
            border-color: rgba(126, 29, 255, 0.5);
        }

        .input-icon {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--accent-primary);
            cursor: pointer;
            font-size: 18px;
            z-index: 2;
            transition: var(--transition);
        }

        .input-icon:hover {
            color: var(--accent-secondary);
        }

        /* Button Styles */
        .btn {
            width: 100%;
            padding: 16px 20px;
            border: none;
            border-radius: var(--radius);
            font-family: 'Chakra Petch', sans-serif;
            font-weight: 600;
            font-size: 16px;
            letter-spacing: 1px;
            text-transform: uppercase;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: var(--transition);
        }

        .btn:hover::before {
            left: 100%;
            transition: 0.7s ease-in-out;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--primary-dark);
            box-shadow: 0 5px 15px rgba(126, 29, 255, 0.3);
        }

        .btn-primary:hover {
            box-shadow: 0 7px 20px rgba(126, 29, 255, 0.5);
            transform: translateY(-2px);
        }

        .btn-icon {
            font-size: 18px;
        }

        /* Pricing Box */
        .pricing-box {
            background: var(--panel-dark);
            border-radius: var(--radius);
            padding: 30px 25px;
            margin: 35px 0 25px;
            border: var(--border-light);
            position: relative;
            overflow: hidden;
        }

        .pricing-box::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at center, rgba(17, 206, 251, 0.07), transparent 70%);
            z-index: 0;
        }

        .pricing-label {
            position: absolute;
            top: 5px;
            right: 30px;
            transform: none;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-tertiary));
            color: var(--text);
            font-size: 12px;
            font-weight: 600;
            padding: 7px 15px;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(253, 58, 255, 0.3);
            letter-spacing: 1px;
            text-transform: uppercase;
            z-index: 10;
            display: block;
        }

        .pricing-amount {
            font-family: 'Chakra Petch', sans-serif;
            font-size: 42px;
            font-weight: 700;
            text-align: center;
            margin: 5px 0 25px;
            color: white;
            position: relative;
            z-index: 1;
            text-shadow: 0 2px 10px rgba(126, 29, 255, 0.5);
        }

        .pricing-currency {
            color: var(--accent-secondary);
            font-size: 24px;
            vertical-align: super;
            margin-right: 5px;
        }

        .pricing-alt {
            display: block;
            text-align: center;
            font-size: 16px;
            color: var(--text-secondary);
            margin-top: -15px;
            margin-bottom: 25px;
            position: relative;
            z-index: 1;
        }

        /* Payment Methods */
        .payment-methods {
            position: relative;
            z-index: 1;
        }

        .payment-method {
            background: rgba(19, 16, 61, 0.5);
            border-radius: var(--radius);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(126, 29, 255, 0.2);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .payment-method:hover {
            transform: translateY(-3px);
            border-color: rgba(126, 29, 255, 0.4);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.2);
            background: rgba(19, 16, 61, 0.7);
        }

        .payment-method::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, var(--accent-primary), var(--accent-secondary));
            opacity: 0;
            transition: var(--transition);
        }

        .payment-method:hover::before {
            opacity: 1;
        }

        .payment-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-family: 'Chakra Petch', sans-serif;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--accent-secondary);
        }

        .payment-icon {
            font-size: 22px;
            color: var(--accent-primary);
        }

        .payment-details {
            position: relative;
            background: rgba(10, 6, 30, 0.7);
            padding: 16px;
            border-radius: var(--radius-sm);
            margin-top: 15px;
            font-family: 'Space Grotesk', monospace;
            font-size: 15px;
            word-break: break-all;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
            border: 1px solid rgba(17, 206, 251, 0.1);
        }

        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(126, 29, 255, 0.15);
            border: 1px solid rgba(126, 29, 255, 0.2);
            color: var(--accent-secondary);
            border-radius: var(--radius-sm);
            padding: 5px 10px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .copy-btn:hover {
            background: rgba(126, 29, 255, 0.3);
            transform: translateY(-2px);
        }

        .copy-btn i {
            font-size: 11px;
        }

        .upload-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 14px;
            margin-top: 15px;
            background: rgba(126, 29, 255, 0.08);
            color: var(--accent-secondary);
            border: 1px solid rgba(126, 29, 255, 0.2);
            border-radius: var(--radius);
            text-align: center;
            text-decoration: none;
            font-weight: 600;
            font-size: 14px;
            transition: var(--transition);
        }

        .upload-btn:hover {
            background: rgba(126, 29, 255, 0.15);
            transform: translateY(-2px);
        }

        /* Trading Interface */
        .trading-section {
            display: none;
        }

        .subscription-status {
            background: var(--panel-dark);
            border-radius: var(--radius);
            padding: 20px;
            margin-bottom: 30px;
            border: var(--border-light);
            position: relative;
            overflow: hidden;
        }

        .subscription-status::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(17, 206, 251, 0.05), transparent);
            z-index: 0;
        }

        .sub-heading {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            position: relative;
            z-index: 1;
        }

        .sub-title {
            font-weight: 500;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .sub-value {
            font-family: 'Chakra Petch', sans-serif;
            font-weight: 600;
            color: var(--success);
        }

        .progress-container {
            height: 10px;
            background: rgba(10, 6, 30, 0.8);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 10px;
            width: 75%;
            position: relative;
            transition: width 1s ease-in-out;
        }

        .progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: progressShine 3s linear infinite;
        }

        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 25px;
        }

        .form-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            font-weight: 500;
            color: var(--accent-secondary);
            font-size: 15px;
        }

        .select-wrapper {
            position: relative;
        }

        .select-field {
            width: 100%;
            padding: 16px 20px;
            border-radius: var(--radius);
            background: rgba(10, 6, 30, 0.6);
            border: var(--border);
            color: var(--text);
            font-size: 16px;
            appearance: none;
            transition: var(--transition);
        }

        .select-field:focus {
            outline: none;
            box-shadow: var(--glow-primary);
            border-color: rgba(126, 29, 255, 0.5);
        }

        .select-arrow {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--accent-primary);
            transition: var(--transition);
        }

        .select-wrapper:hover .select-arrow {
            color: var(--accent-secondary);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--accent-primary), var(--success));
            color: var(--primary-dark);
        }

        .btn-success:hover {
            box-shadow: 0 7px 20px rgba(0, 255, 195, 0.3);
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--accent-primary), var(--warning));
            color: var(--primary-dark);
            margin-top: 15px;
        }

        .btn-warning:hover {
            box-shadow: 0 7px 20px rgba(255, 193, 55, 0.3);
        }

        /* Loading Indicator */
        .loading {
            display: none;
            text-align: center;
            padding: 30px 20px;
        }

        .loader {
            position: relative;
            width: 60px;
            height: 60px;
            margin: 0 auto 20px;
        }

        .loader-circle {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: var(--accent-primary);
            animation: spin 1.5s linear infinite;
        }

        .loader-circle:nth-child(2) {
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            border-top-color: var(--accent-secondary);
            animation-duration: 2s;
            animation-direction: reverse;
        }

        .loader-circle:nth-child(3) {
            width: 60%;
            height: 60%;
            top: 20%;
            left: 20%;
            border-top-color: var(--accent-tertiary);
            animation-duration: 1s;
        }

        .loading-text {
            font-family: 'Chakra Petch', sans-serif;
            color: var(--text);
            font-size: 16px;
            font-weight: 500;
            opacity: 0.8;
            letter-spacing: 0.5px;
        }

        .loading-dots {
            display: inline-block;
        }

        .loading-dots::after {
            content: '';
            animation: loadingDots 1.5s infinite;
        }

        @keyframes loadingDots {
            0% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
            100% { content: ''; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Signal Display */
        .signal-display {
            display: none;
            background: var(--panel-dark);
            border-radius: var(--radius);
            padding: 30px 20px;
            margin-top: 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
            z-index: 1;
            animation: fadeIn 0.7s ease-out;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }

        .signal-display::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(126, 29, 255, 0.1), transparent 70%);
            z-index: -1;
        }

        .signal-display.buy {
            border: 1px solid rgba(0, 255, 195, 0.3);
            box-shadow: 0 5px 20px rgba(0, 255, 195, 0.2);
        }

        .signal-display.sell {
            border: 1px solid rgba(255, 41, 118, 0.3);
            box-shadow: 0 5px 20px rgba(255, 41, 118, 0.2);
        }

        .signal-badge {
            position: absolute;
            top: 5px;
            right: 25px;
            transform: none;
            background: linear-gradient(90deg, var(--warning), var(--accent-tertiary));
            color: var(--primary-dark);
            font-size: 12px;
            font-weight: 600;
            padding: 7px 15px;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(255, 193, 55, 0.3);
            font-family: 'Chakra Petch', sans-serif;
            letter-spacing: 1px;
            z-index: 10;
            display: block;
        }

        .signal-indicator {
            font-size: 60px;
            margin-bottom: 15px;
            color: var(--success);
            animation: pulseIcon 2s infinite;
        }

        .signal-display.sell .signal-indicator {
            color: var(--danger);
        }

        @keyframes pulseIcon {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .signal-title {
            font-family: 'Chakra Petch', sans-serif;
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 15px;
            color: var(--success);
            letter-spacing: 1px;
        }

        .signal-display.sell .signal-title {
            color: var(--danger);
        }

        .signal-pair {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 10px;
            color: var(--text);
        }

        .signal-timing {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-family: 'Space Grotesk', monospace;
            font-size: 16px;
            color: var(--text-secondary);
        }

        .signal-time-value {
            color: var(--accent-secondary);
            font-weight: 600;
        }

        .quantum-tag {
            margin-top: 15px;
            display: inline-block;
            background: rgba(253, 58, 255, 0.1);
            border: 1px solid rgba(253, 58, 255, 0.2);
            padding: 7px 15px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-tertiary);
        }

        /* Continuation of CSS */
        .data-source-tag {
           margin-top: 10px;
           display: none;
           background: rgba(0, 255, 195, 0.1);
           border: 1px solid rgba(0, 255, 195, 0.2);
           padding: 7px 15px;
           border-radius: 20px;
           font-size: 13px;
           font-weight: 600;
           color: var(--success);
       }

       /* Trend and pattern badges */
       .trend-badge {
           margin-top: 10px;
           display: inline-block;
           background: rgba(17, 206, 251, 0.1);
           border: 1px solid rgba(17, 206, 251, 0.2);
           padding: 7px 15px;
           border-radius: 20px;
           font-size: 13px;
           font-weight: 600;
           color: var(--accent-secondary);
       }

       .sr-badge {
           margin-top: 10px;
           display: inline-block;
           background: rgba(255, 193, 55, 0.1);
           border: 1px solid rgba(255, 193, 55, 0.2);
           padding: 7px 15px;
           border-radius: 20px;
           font-size: 13px;
           font-weight: 600;
           color: var(--warning);
       }

       /* Disclaimer */
       .disclaimer {
           margin: 25px 0;
           padding: 16px;
           background: rgba(255, 193, 55, 0.05);
           border-radius: var(--radius);
           border: 1px solid rgba(255, 193, 55, 0.2);
           display: flex;
           align-items: flex-start;
           gap: 12px;
       }

       .disclaimer-checkbox {
           appearance: none;
           width: 20px;
           height: 20px;
           background: rgba(10, 6, 30, 0.8);
           border: 1px solid rgba(126, 29, 255, 0.3);
           border-radius: 4px;
           cursor: pointer;
           position: relative;
           margin-top: 2px;
       }

       .disclaimer-checkbox:checked {
           background: var(--accent-primary);
           border-color: var(--accent-primary);
       }

       .disclaimer-checkbox:checked::after {
           content: 'âœ“';
           position: absolute;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           color: white;
           font-size: 12px;
       }

       .disclaimer-text {
           font-size: 14px;
           color: var(--text-secondary);
           line-height: 1.5;
       }

       /* WhatsApp Float Button */
       .whatsapp-float {
           position: fixed;
           bottom: 30px;
           right: 30px;
           width: 60px;
           height: 60px;
           background: linear-gradient(135deg, #25d366, #128c7e);
           border-radius: 50%;
           display: flex;
           align-items: center;
           justify-content: center;
           color: white;
           font-size: 24px;
           box-shadow: 0 5px 15px rgba(37, 211, 102, 0.5);
           transition: all 0.3s cubic-bezier(0.17, 0.67, 0.45, 0.99);
           z-index: 999;
       }

       .whatsapp-float:hover {
           transform: scale(1.1) rotate(10deg);
           box-shadow: 0 8px 25px rgba(37, 211, 102, 0.7);
       }

       /* Footer */
       .footer {
           text-align: center;
           padding: 25px 20px;
           background: var(--panel);
           border-top: var(--border);
           font-size: 13px;
           color: var(--text-secondary);
           border-radius: 0 0 var(--radius-lg) var(--radius-lg);
       }

       /* Redirect Overlay */
       .redirect-overlay {
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: rgba(10, 6, 30, 0.95);
           backdrop-filter: blur(10px);
           display: none;
           justify-content: center;
           align-items: center;
           z-index: 1000;
           animation: fadeIn 0.5s ease;
       }

       .redirect-content {
           max-width: 500px;
           padding: 40px 30px;
           background: var(--panel);
           border-radius: var(--radius-lg);
           border: var(--border);
           text-align: center;
           position: relative;
           box-shadow: var(--glow-primary);
       }

       .redirect-title {
           font-family: 'Chakra Petch', sans-serif; 
           font-size: 26px;
           font-weight: 700;
           margin-bottom: 20px;
           color: var(--accent-primary);
           background: linear-gradient(90deg, var(--accent-primary), var(--accent-tertiary));
           -webkit-background-clip: text;
           background-clip: text;
           -webkit-text-fill-color: transparent;
       }

       .redirect-text {
           font-size: 16px;
           line-height: 1.6;
           margin-bottom: 30px;
           color: var(--text);
       }

       .redirect-btn {
           display: inline-block;
           padding: 16px 30px;
           background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
           color: var(--primary-dark);
           border-radius: var(--radius);
           text-decoration: none;
           font-family: 'Chakra Petch', sans-serif;
           font-weight: 600;
           font-size: 16px;
           transition: var(--transition);
           position: relative;
           overflow: hidden;
       }

       .redirect-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
           transition: var(--transition);
       }

       .redirect-btn:hover::before {
           left: 100%;
           transition: 0.7s ease-in-out;
       }

       .redirect-btn:hover {
           transform: translateY(-3px);
           box-shadow: var(--glow-secondary);
       }

       .close-btn {
           position: absolute;
           top: 15px;
           right: 15px;
           width: 30px;
           height: 30px;
           background: rgba(126, 29, 255, 0.1);
           border-radius: 50%;
           display: flex;
           align-items: center;
           justify-content: center;
           color: var(--accent-secondary);
           font-size: 18px;
           cursor: pointer;
           transition: var(--transition);
       }

       .close-btn:hover {
           background: rgba(126, 29, 255, 0.2);
           transform: rotate(90deg);
       }

       /* Analysis Panel */
       .analysis-panel {
           display: none;
           background: var(--panel-dark);
           border-radius: var(--radius);
           padding: 20px;
           margin-top: 30px;
           border: var(--border-light);
       }

       .analysis-title {
           font-family: 'Chakra Petch', sans-serif;
           font-size: 16px;
           font-weight: 600;
           margin-bottom: 15px;
           color: var(--accent-tertiary);
           display: flex;
           align-items: center;
           gap: 8px;
       }

       .analysis-section {
           margin-bottom: 15px;
       }

       .analysis-row {
           display: flex;
           justify-content: space-between;
           padding: 8px 0;
           border-bottom: 1px solid rgba(126, 29, 255, 0.1);
       }

       .analysis-label {
           font-size: 14px;
           color: var(--text-secondary);
       }

       .analysis-value {
           font-family: 'Space Grotesk', monospace;
           font-weight: 500;
           font-size: 14px;
           color: var(--accent-secondary);
       }

       .analysis-value.bullish {
           color: var(--success);
       }

       .analysis-value.bearish {
           color: var(--danger);
       }

       /* Market analysis styles */
       .market-recommendation {
           margin-top: 20px; 
           padding: 15px; 
           border-radius: var(--radius); 
           background: rgba(19, 16, 61, 0.7);
           border: var(--border-light);
           line-height: 1.6;
           font-size: 14px;
       }

       /* Animations */
       @keyframes fadeIn {
           from { opacity: 0; transform: translateY(10px); }
           to { opacity: 1; transform: translateY(0); }
       }

       /* Floating particles animation */
       .particles-container {
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           overflow: hidden;
           pointer-events: none;
           z-index: 0;
       }

       .particle {
           position: absolute;
           width: 2px;
           height: 2px;
           background: var(--accent-primary);
           border-radius: 50%;
           opacity: 0;
           animation: float 15s infinite ease-in-out;
       }

       .particle:nth-child(even) {
           background: var(--accent-secondary);
       }

       .particle:nth-child(3n) {
           background: var(--accent-tertiary);
       }

       @keyframes float {
           0% {
               opacity: 0;
               transform: translateY(0) translateX(0);
           }
           10% {
               opacity: 0.5;
           }
           90% {
               opacity: 0.5;
           }
           100% {
               opacity: 0;
               transform: translateY(-100vh) translateX(100px);
           }
       }

       /* Responsive Styles */
       @media (max-width: 500px) {
           .platform-selection {
               grid-template-columns: 1fr;
           }

           .pricing-amount {
               font-size: 36px;
           }

           .logo-text {
               font-size: 24px;
           }

           .signal-title {
               font-size: 24px;
           }

           .whatsapp-float {
               bottom: 20px;
               right: 20px;
               width: 50px;
               height: 50px;
               font-size: 20px;
           }

           .content {
               padding: 25px 20px;
           }
           
           .security-alert {
               margin-top: 15px;
               padding: 12px;
               background: rgba(255, 193, 55, 0.1);
               border: 1px solid rgba(255, 193, 55, 0.3);
               border-radius: var(--radius-sm);
               font-size: 13px;
               line-height: 1.5;
               color: var(--warning);
               text-align: left;
           }

           .security-alert i {
               margin-right: 6px;
               color: var(--warning);
           }
       }
    </style>
</head>
<body>
    <!-- Particles animation container -->
    <div class="particles-container" id="particlesContainer"></div>

    <div class="container">
        <div class="card">
            <div class="header">
                <div class="header-content">
                    <h1 class="logo-text"><span>BINARY BEAST PRO 2.0</span></h1>
                    <p class="tagline">AI-Powered Quantum Trading Signals</p>
                </div>
            </div>

            <div class="content">
                <!-- Access Status Bar (initially hidden) -->
                <div class="status-bar" id="accessStatus" style="display: none;">
                    <div class="status-indicator">
                        <div class="status-dot"></div>
                        <span class="status-text">Premium Access</span>
                    </div>
                    <div class="status-countdown" id="accessExpiration">
                        29/04/2025 23:59
                    </div>
                </div>

                <!-- Platform Selection -->
                <h2 class="section-title"><i class="fas fa-exchange-alt"></i> Trading Platform</h2>
                <div class="platform-selection" id="platformSelection">
                    <button class="platform-btn active" data-platform="quotex">
                        <div class="platform-icon">
                            <i class="fas fa-chart-line"></i>
                        </div>
                        <span class="platform-name">Quotex</span>
                    </button>
                    <button class="platform-btn" data-platform="pocket">
                        <div class="platform-icon">
                            <i class="fas fa-mobile-alt"></i>
                        </div>
                        <span class="platform-name">Pocket Option</span>
                    </button>
                </div>

                <!-- Password Section -->
                <div id="passwordSection" class="password-section">
                    <h2 class="section-title"><i class="fas fa-key"></i> Access Control</h2>
                    <div class="input-group">
                        <span class="input-label">EMAIL ADDRESS</span>
                        <input type="email" id="emailInput" class="input-field" placeholder="Enter your email address">
                        <i class="fas fa-envelope input-icon"></i>
                    </div>
                    <div class="input-group">
                        <span class="input-label">QUANTUM ACCESS CODE</span>
                        <input type="password" id="passwordInput" class="input-field" placeholder="Enter your access code">
                        <i class="fas fa-eye input-icon" id="togglePassword"></i>
                    </div>
                    <button id="submitPassword" class="btn btn-primary">
                        <span class="btn-icon"><i class="fas fa-unlock-alt"></i></span>
                        <span>UNLOCK PRO SIGNALS</span>
                    </button>

                    <!-- Pricing Box -->
                    <div class="pricing-box">
                        <span class="pricing-label">Limited Time</span>
                        <div class="pricing-amount"><span class="pricing-currency">$</span>70</div>
                        <div class="pricing-alt">or 63 EUR</div>
                        
                        <div class="payment-methods">
                            <div class="payment-method">
                                <div class="payment-title">
                                    <span class="payment-icon"><i class="fab fa-bitcoin"></i></span>
                                    <span>Binance Pay</span>
                                </div>
                                <div class="payment-details" id="binanceId">
                                    527147599
                                    <button class="copy-btn" data-target="binanceId">
                                        <i class="fas fa-copy"></i> COPY
                                    </button>
                                </div>
                            </div>
                            
                            <div class="payment-method">
                                <div class="payment-title">
                                    <span class="payment-icon"><i class="fas fa-wallet"></i></span>
                                    <span>Easypaisa</span>
                                </div>
                                <div class="payment-details" id="easypaisaAccount">
                                    Ahad Hussain Sharif- 03495077738
                                    <button class="copy-btn" data-target="easypaisaAccount">
                                        <i class="fas fa-copy"></i> COPY
                                    </button>
                                </div>
                                <a href="https://docs.google.com/forms/d/e/1FAIpQLSdHEoap65BDD3pGq0pJT_ZrZEMD2cRUN_Wy-nsq9Ky-o8YFKg/viewform?usp=dialog" class="upload-btn" target="_blank">
                                    <i class="fas fa-upload"></i> UPLOAD PAYMENT PROOF
                                </a>
                            </div>
                        </div>
                    </div>

                    <!-- Disclaimer -->
                    <div class="disclaimer">
                        <input type="checkbox" id="disclaimerCheck" class="disclaimer-checkbox" checked disabled>
                        <label for="disclaimerCheck" class="disclaimer-text">I understand that trading involves risk and I agree to the terms of service. Binary Beast Pro is not responsible for any financial losses.</label>
                    </div>

                    <!-- WhatsApp Button -->
                    <a href="https://wa.link/7iqkci" class="btn btn-primary" style="margin-top: 20px;">
                        <span class="btn-icon"><i class="fab fa-whatsapp"></i></span>
                        <span>GET ACCESS VIA WHATSAPP</span>
                    </a>
                </div>

                <!-- Trading Section -->
                <div id="tradingSection" class="trading-section">
                    <!-- Subscription Status -->
                    <div class="subscription-status">
                        <div class="sub-heading">
                            <span class="sub-title">Subscription Status</span>
                            <span class="sub-value" id="subscriptionInfo">Active (25 days left)</span>
                        </div>
                        <div class="progress-container">
                            <div class="progress-bar" id="progressBar"></div>
                        </div>
                    </div>

                    <!-- Pair Selection -->
                    <div class="form-group">
                        <label class="form-label">
                            <i class="fas fa-project-diagram"></i> SELECT TRADING PAIR
                        </label>
                        <div class="select-wrapper">
                            <select id="pairSelect" class="select-field">
                                <!-- Forex Pairs -->
                                <option value="EUR/USD">EUR/USD</option>
                                <option value="GBP/USD">GBP/USD</option>
                                <option value="USD/JPY">USD/JPY</option>
                                <option value="AUD/USD">AUD/USD</option>
                                <option value="USD/CAD">USD/CAD</option>
                                <option value="NZD/USD">NZD/USD</option>
                                <option value="EUR/GBP">EUR/GBP</option>
                                <option value="USD/CHF">USD/CHF</option>
                                
                                <!-- OTC Pairs -->
                                <option value="USD/BDT">USD/BDT OTC</option>
                                <option value="EUR/CHF">EUR/CHF OTC</option>
                                <option value="USD/BRL">USD/BRL OTC</option>
                                <option value="USD/DZD">USD/DZD OTC</option>
                                <option value="USD/NGN">USD/NGN OTC</option>
                                <option value="CHF/JPY">CHF/JPY OTC</option>
                                <option value="EUR/CAD">EUR/CAD OTC</option>
                                
                                <!-- Other Assets -->
                                <option value="XAU/USD">GOLD (XAU/USD)</option>
                                <option value="XAG/USD">SILVER (XAG/USD)</option>
                                <option value="BTC/USD">BTC/USD</option>
                            </select>
                            <i class="fas fa-chevron-down select-arrow"></i>
                        </div>
                    </div>

                    <!-- Timeframe Selection -->
                    <div class="form-group">
                        <label class="form-label">
                            <i class="fas fa-clock"></i> SELECT TIMEFRAME
                        </label>
                        <div class="select-wrapper">
                            <select id="timeSelect" class="select-field">
                                <option value="5">5 Seconds</option>
                                <option value="15">15 Seconds</option>
                                <option value="30">30 Seconds</option>
                                <option value="60">1 Minute</option>
                                <option value="300">5 Minutes</option>
                            </select>
                            <i class="fas fa-chevron-down select-arrow"></i>
                        </div>
                    </div>

                    <!-- Signal Buttons -->
                    <button id="getSignal" class="btn btn-success">
                        <span class="btn-icon"><i class="fas fa-bolt"></i></span>
                        <span>GENERATE SIGNAL (75% ACC)</span>
                    </button>

                    <button id="ultraMode" class="btn btn-warning">
                        <span class="btn-icon"><i class="fas fa-atom"></i></span>
                        <span>QUANTUM MODE (85% ACC)</span>
                    </button>
                    
                    <!-- Market Analysis Button (NEW) -->
                    <button id="marketAnalysis" class="btn btn-primary" style="margin-top: 15px;">
                        <span class="btn-icon"><i class="fas fa-chart-line"></i></span>
                        <span>MARKET ANALYSIS</span>
                    </button>

                    <!-- Loading Indicator -->
                    <div class="loading" id="loadingIndicator">
                        <div class="loader">
                            <div class="loader-circle"></div>
                            <div class="loader-circle"></div>
                            <div class="loader-circle"></div>
                        </div>
                        <p class="loading-text">ANALYZING MARKET WITH QUANTUM AI<span class="loading-dots"></span></p>
                    </div>

                    <!-- Signal Display -->
                    <div id="signalContainer" class="signal-display">
                        <div class="signal-badge" id="signalBadge">COMPOUNDING</div>
                        <div class="signal-indicator" id="signalIcon">
                            <i class="fas fa-arrow-up"></i>
                        </div>
                        <div class="signal-title" id="signalText">BINARYBEAST BUY</div>
                        <div class="signal-pair" id="signalPair">EUR/USD</div>
                        <div class="signal-timing">
                            <i class="far fa-clock"></i>
                            <span>Expires in: <span class="signal-time-value" id="signalTime">30 Seconds</span></span>
                        </div>
                        <div class="quantum-tag" id="quantumTag">QUANTUM ANALYSIS</div>
                        <div class="data-source-tag" id="dataSourceIndicator">LIVE MARKET DATA</div>
                        <div class="trend-badge" id="trendIndicator">TREND: BULLISH</div>
                        <div class="sr-badge" id="srIndicator">S: 1.07500 | R: 1.08200</div>
                    </div>
                    
                    <!-- Market Analysis Container (NEW) -->
                    <div id="marketAnalysisContainer" class="analysis-panel" style="display: none;">
                        <h3 class="analysis-title"><i class="fas fa-microscope"></i> MARKET CONDITION ANALYSIS</h3>
                        <div class="analysis-section">
                            <div class="analysis-row">
                                <span class="analysis-label">Market Structure</span>
                                <span class="analysis-value" id="marketStructure">Loading...</span>
                            </div>
                            <div class="analysis-row">
                                <span class="analysis-label">Volatility Level</span>
                                <span class="analysis-value" id="volatilityLevel">Loading...</span>
                            </div>
                            <div class="analysis-row">
                                <span class="analysis-label">Trading Session</span>
                                <span class="analysis-value" id="tradingSession">Loading...</span>
                            </div>
                            <div class="analysis-row">
                                <span class="analysis-label">Signal Quality</span>
                                <span class="analysis-value" id="signalQuality">Loading...</span>
                            </div>
                        </div>
                        <div class="market-recommendation" id="marketRecommendation">
                            Loading recommendation...
                        </div>
                    </div>

                    <!-- Analysis Panel -->
                    <div id="analysisPanel" class="analysis-panel">
                        <h3 class="analysis-title"><i class="fas fa-chart-bar"></i> DETAILED MARKET ANALYSIS</h3>
                        <div class="analysis-section">
                            <div class="analysis-row">
                                <span class="analysis-label">Market Trend (1H)</span>
                                <span class="analysis-value" id="trend1h">Bullish</span>
                            </div>
                            <div class="analysis-row">
                                <span class="analysis-label">Market Trend (15M)</span>
                                <span class="analysis-value" id="trend15m">Bullish</span>
                            </div>
                            <div class="analysis-row">
                                <span class="analysis-label">Market Trend (5M)</span>
                                <span class="analysis-value" id="trend5m">Neutral</span>
                            </div>
                        </div>
                        <div class="analysis-section">
                            <div class="analysis-row">
                                <span class="analysis-label">Pattern Detected</span>
                                <span class="analysis-value" id="patternDetected">Bullish Engulfing</span>
                            </div>
                            <div class="analysis-row">
                                <span class="analysis-label">RSI (14)</span>
                                <span class="analysis-value" id="rsiValue">48.72</span>
                            </div>
                            <div class="analysis-row">
                                <span class="analysis-label">MACD</span>
                                <span class="analysis-value" id="macdValue">0.00124</span>
                            </div>
                        </div>
                        <div class="analysis-section">
                            <div class="analysis-row">
                                <span class="analysis-label">Closest Support</span>
                                <span class="analysis-value" id="supportValue">1.07500</span>
                            </div>
                            <div class="analysis-row">
                                <span class="analysis-label">Closest Resistance</span>
                                <span class="analysis-value" id="resistanceValue">1.08200</span>
                            </div>
                            <div class="analysis-row">
                                <span class="analysis-label">Current Price</span>
                                <span class="analysis-value" id="currentPrice">1.07856</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="footer">
                Â© 2025 BINARY BEAST PRO | Not financial advice | High risk investment
                <p class="security-alert">
                    <i class="fas fa-exclamation-triangle"></i> IMPORTANT SECURITY ALERT: Sharing your login credentials (Email & Password) with anyone will result in your account being permanently banned and your access code immediately deactivated. Our system automatically detects multiple login attempts from different locations. For your security and to protect your investment, keep your credentials strictly confidential.
                </p>
            </div>
        </div>
    </div>

    <!-- WhatsApp Float -->
    <a href="https://wa.link/7iqkci" class="whatsapp-float" target="_blank">
        <i class="fab fa-whatsapp"></i>
    </a>

    <!-- Redirect Overlay -->
    <div id="redirectOverlay" class="redirect-overlay">
        <div class="redirect-content">
            <div class="close-btn" id="closeRedirect">Ã—</div>
            <h3 class="redirect-title">JOIN OUR PREMIUM COMMUNITY</h3>
            <p class="redirect-text">For advanced trading strategies, signals, and expert support, join our exclusive trading community at Binary Beast</p>
            <a href="https://t.me/binary_beaxt" class="redirect-btn" target="_blank">
                <i class="fab fa-telegram-plane"></i> JOIN BINARYWALA NOW
            </a>
        </div>
    </div>

    <script>
        // OANDA API Configuration
        const OANDA_API_KEY = 'eb2326208921b413a87728832f191f03-d9be68b74884f7d3107b9f05ca305319';
        const OANDA_API_URL = 'https://api-fxpractice.oanda.com/v3/instruments/';

        // DOM Elements
        const emailInput = document.getElementById("emailInput");
        const passwordInput = document.getElementById("passwordInput");
        const togglePassword = document.getElementById("togglePassword");
        const submitPassword = document.getElementById("submitPassword");
        const passwordSection = document.getElementById("passwordSection");
        const tradingSection = document.getElementById("tradingSection");
        const disclaimerCheck = document.getElementById("disclaimerCheck");
        const platformBtns = document.querySelectorAll(".platform-btn");
        const accessStatus = document.getElementById("accessStatus");
        const accessExpiration = document.getElementById("accessExpiration");
        const progressBar = document.getElementById("progressBar");
        const subscriptionInfo = document.getElementById("subscriptionInfo");
        const getSignalBtn = document.getElementById("getSignal");
        const ultraModeBtn = document.getElementById("ultraMode");
        const marketAnalysisBtn = document.getElementById("marketAnalysis");
        const loadingIndicator = document.getElementById("loadingIndicator");
        const signalContainer = document.getElementById("signalContainer");
        const signalIcon = document.getElementById("signalIcon");
        const signalText = document.getElementById("signalText");
        const signalPair = document.getElementById("signalPair");
        const signalTime = document.getElementById("signalTime");
        const signalBadge = document.getElementById("signalBadge");
        const quantumTag = document.getElementById("quantumTag");
        const dataSourceIndicator = document.getElementById("dataSourceIndicator");
        const trendIndicator = document.getElementById("trendIndicator");
        const srIndicator = document.getElementById("srIndicator");
        const pairSelect = document.getElementById("pairSelect");
        const timeSelect = document.getElementById("timeSelect");
        const analysisPanel = document.getElementById("analysisPanel");
        const marketAnalysisContainer = document.getElementById("marketAnalysisContainer");
        const marketStructure = document.getElementById("marketStructure");
        const volatilityLevel = document.getElementById("volatilityLevel");
        const tradingSession = document.getElementById("tradingSession");
        const signalQuality = document.getElementById("signalQuality");
        const marketRecommendation = document.getElementById("marketRecommendation");
        const trend1h = document.getElementById("trend1h");
        const trend15m = document.getElementById("trend15m");
        const trend5m = document.getElementById("trend5m");
        const patternDetected = document.getElementById("patternDetected");
        const rsiValue = document.getElementById("rsiValue");
        const macdValue = document.getElementById("macdValue");
        const supportValue = document.getElementById("supportValue");
        const resistanceValue = document.getElementById("resistanceValue");
        const currentPrice = document.getElementById("currentPrice");
        const particlesContainer = document.getElementById('particlesContainer');
        const closeRedirect = document.getElementById("closeRedirect");
        const redirectOverlay = document.getElementById("redirectOverlay");

        // Enhanced Password Protection with Email Verification System
        const licenses = {
            "ahadhussainsharif.com": {
                password: "Bubloo786#",
                expirationDate: new Date(2025, 4, 29, 23, 59, 59), // Year, Month (0-based), Day, Hour, Min, Sec
                accessDays: 30,
                expired: false
            },
            "automatic567screen@gmail.com": {
                password: "PREMIUM2025",
                expirationDate: new Date(2025, 5, 15, 23, 59, 59),
                accessDays: 45,
                expired: false
            },
            "Binarybeast@.gmailcom": {
                password: "Beast2025",
                expirationDate: new Date(2025, 4, 15, 23, 59, 59),
                accessDays: 7,
                expired: false
            }
        };

        // Format date as DD/MM/YYYY HH:MM
        function formatDate(date) {
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            
            return `${day}/${month}/${year} ${hours}:${minutes}`;
        }

        // Calculate remaining days between dates
        function calculateRemainingDays(expirationDate) {
            const now = new Date();
            const diff = expirationDate - now;
            return Math.ceil(diff / (1000 * 60 * 60 * 24));
        }

        // Update subscription progress bar
        function updateSubscriptionProgress(accessInfo) {
            try {
                const totalDays = accessInfo.accessDays || 30;
                const remainingDays = calculateRemainingDays(accessInfo.expirationDate);
                const percentage = ((totalDays - remainingDays) / totalDays) * 100;
                
                if (progressBar) {
                    progressBar.style.width = `${Math.max(0, 100 - percentage)}%`;
                }
                
                if (subscriptionInfo) {
                    if (remainingDays <= 0) {
                        subscriptionInfo.textContent = "Expired";
                        subscriptionInfo.style.color = "var(--danger)";
                    } else if (remainingDays <= 3) {
                        subscriptionInfo.textContent = `Expires in ${remainingDays} day${remainingDays !== 1 ? 's' : ''}`;
                        subscriptionInfo.style.color = "var(--danger)";
                    } else if (remainingDays <= 7) {
                        subscriptionInfo.textContent = `Expires in ${remainingDays} days`;
                        subscriptionInfo.style.color = "var(--warning)";
                    } else {
                        subscriptionInfo.textContent = `Active (${remainingDays} days left)`;
                        subscriptionInfo.style.color = "var(--success)";
                    }
                }
            } catch (error) {
                console.error("Error updating subscription progress:", error);
                // Set default values in case of error
                if (progressBar) progressBar.style.width = "75%";
                if (subscriptionInfo) subscriptionInfo.textContent = "Active";
            }
        }

        // Enhanced OANDA API Integration with retry mechanism
        async function fetchOandaData(instrument, granularity = 'H1', count = 100) {
            const oandaInstrument = instrument.replace('/', '_');
            const maxRetries = 3;
            let retryCount = 0;
            
            while (retryCount < maxRetries) {
                try {
                    const response = await fetch(`${OANDA_API_URL}${oandaInstrument}/candles?count=${count}&price=M&granularity=${granularity}`, {
                        headers: {
                            'Authorization': `Bearer ${OANDA_API_KEY}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Validate data format
                    if (!data.candles || !Array.isArray(data.candles)) {
                        throw new Error('Invalid data format received');
                    }
                    
                    return data.candles;
                } catch (error) {
                    console.error(`Error fetching OANDA data (attempt ${retryCount + 1}/${maxRetries}):`, error);
                    retryCount++;
                    
                    if (retryCount >= maxRetries) {
                        console.error('Maximum retries reached, falling back to simulated data');
                        return generateSimulatedCandles(granularity, count);
                    }
                    
                    // Wait before retry with exponential backoff
                    await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, retryCount)));
                }
            }
        }

        // Fallback: Generate simulated candles when API fails
        function generateSimulatedCandles(granularity, count) {
            const candles = [];
            const basePrice = 1.05 + Math.random() * 0.1; // Random base around 1.05-1.15
            let currentPrice = basePrice;
            
            for (let i = 0; i < count; i++) {
                // Generate realistic price movement
                const volatility = 0.0005; // 0.05% volatility per candle
                const change = (Math.random() - 0.5) * volatility * 2;
                currentPrice = currentPrice * (1 + change);
                
                // Generate open, high, low, close prices
                const open = currentPrice;
                const close = open * (1 + (Math.random() - 0.5) * volatility);
                const high = Math.max(open, close) * (1 + Math.random() * volatility);
                const low = Math.min(open, close) * (1 - Math.random() * volatility);
                
                candles.push({
                    time: new Date(Date.now() - (count - i) * getGranularityMilliseconds(granularity)).toISOString(),
                    complete: i < count - 1,
                    volume: Math.floor(Math.random() * 1000) + 100,
                    mid: {
                        o: open.toFixed(5),
                        h: high.toFixed(5),
                        l: low.toFixed(5),
                        c: close.toFixed(5)
                    }
                });
                
                currentPrice = close;
            }
            
            return candles;
        }

        // Convert granularity to milliseconds
        function getGranularityMilliseconds(granularity) {
            switch(granularity) {
                case 'M1': return 60 * 1000;
                case 'M5': return 5 * 60 * 1000;
                case 'M15': return 15 * 60 * 1000;
                case 'H1': return 60 * 60 * 1000;
                default: return 60 * 1000; // Default to 1 minute
            }
        }

        // Enhanced pattern detection with more accurate recognition
        function detectPatterns(candles) {
            if (!candles || candles.length < 20) return [];
            
            const patterns = [];
            const prices = candles.map(candle => ({
                open: parseFloat(candle.mid.o),
                high: parseFloat(candle.mid.h),
                low: parseFloat(candle.mid.l),
                close: parseFloat(candle.mid.c),
                volume: Math.abs(parseFloat(candle.mid.h) - parseFloat(candle.mid.l))
            }));
            
            // Bullish Engulfing Pattern with confirmation
            for (let i = 3; i < prices.length; i++) {
                const curr = prices[i];
                const prev = prices[i-1];
                const prevprev = prices[i-2];
                const prevprevprev = prices[i-3];
                
                // Bullish Engulfing with volume confirmation
                if (prev.close < prev.open && // Previous candle is bearish
                    curr.close > curr.open && // Current candle is bullish
                    curr.open <= prev.close && // Current opens at or below previous close
                    curr.close > prev.open && // Current closes above previous open
                    curr.volume > prev.volume * 1.15) { // Volume confirmation with 15% increase
                    
                    // Check prior trend context (more reliable if appears in downtrend)
                    let priorDowntrend = prevprev.close < prevprev.open && prevprevprev.close < prevprevprev.open;
                    let additionalConfidence = priorDowntrend ? 0.1 : 0;
                    
                    // Check for confirmation by breaking above previous resistance
                    let breakingResistance = false;
                    for (let j = i-5; j < i-1; j++) {
                        if (j >= 0 && curr.close > prices[j].high) {
                            breakingResistance = true;
                            break;
                        }
                    }
                    additionalConfidence += breakingResistance ? 0.1 : 0;
                    
                    patterns.push({
                        name: 'Bullish Engulfing',
                        position: i,
                        signal: 'buy',
                        strength: 0.85 + additionalConfidence
                    });
                }
                
                // Bearish Engulfing with volume confirmation
                if (prev.close > prev.open && // Previous candle is bullish
                    curr.close < curr.open && // Current candle is bearish
                    curr.open >= prev.close && // Current opens at or above previous close
                    curr.close < prev.open && // Current closes below previous open
                    curr.volume > prev.volume * 1.15) { // Volume confirmation
                    
                    // Check prior trend context (more reliable if appears in uptrend)
                    let priorUptrend = prevprev.close > prevprev.open && prevprevprev.close > prevprevprev.open;
                    let additionalConfidence = priorUptrend ? 0.1 : 0;
                    
                    // Check for confirmation by breaking below previous support
                    let breakingSupport = false;
                    for (let j = i-5; j < i-1; j++) {
                        if (j >= 0 && curr.close < prices[j].low) {
                            breakingSupport = true;
                            break;
                        }
                    }
                    additionalConfidence += breakingSupport ? 0.1 : 0;
                    
                    patterns.push({
                        name: 'Bearish Engulfing',
                        position: i,
                        signal: 'sell',
                        strength: 0.85 + additionalConfidence
                    });
                }
            }
            
            // Hammer and Shooting Star patterns with stronger confirmation
            for (let i = 3; i < prices.length; i++) {
                const p = prices[i];
                const prev = prices[i-1];
                const body = Math.abs(p.close - p.open);
                const totalSize = p.high - p.low;
                const lowerShadow = Math.min(p.open, p.close) - p.low;
                const upperShadow = p.high - Math.max(p.open, p.close);
                
                // Prevent division by zero
                if (totalSize === 0) continue;
                
                // Hammer (bullish) with downtrend confirmation
                if (body / totalSize < 0.3 && 
                    lowerShadow > 2 * body && 
                    upperShadow < 0.1 * totalSize) {
                    
                    // Confirm with downtrend context
                    let inDowntrend = true;
                    for (let j = i-5; j < i; j++) {
                        if (j >= 0 && prices[j].close > prices[j+1].close) {
                            inDowntrend = false;
                            break;
                        }
                    }
                    
                    if (inDowntrend) {
                        // Check next candle for confirmation (if available)
                        let confirmationBonus = 0;
                        if (i < prices.length - 1 && prices[i+1].close > p.close) {
                            confirmationBonus = 0.1;
                        }
                        
                        patterns.push({
                            name: 'Hammer',
                            position: i,
                            signal: 'buy',
                            strength: 0.8 + confirmationBonus
                        });
                    }
                }
                
                // Shooting Star (bearish) with uptrend confirmation
                if (body / totalSize < 0.3 && 
                    upperShadow > 2 * body && 
                    lowerShadow < 0.1 * totalSize) {
                    
                    // Confirm with uptrend context
                    let inUptrend = true;
                    for (let j = i-5; j < i; j++) {
                        if (j >= 0 && prices[j].close < prices[j+1].close) {
                            inUptrend = false;
                            break;
                        }
                    }
                    
                    if (inUptrend) {
                        // Check next candle for confirmation (if available)
                        let confirmationBonus = 0;
                        if (i < prices.length - 1 && prices[i+1].close < p.close) {
                            confirmationBonus = 0.1;
                        }
                        
                        patterns.push({
                            name: 'Shooting Star',
                            position: i,
                            signal: 'sell',
                            strength: 0.8 + confirmationBonus
                        });
                    }
                }
            }
            
            // Enhanced Doji detection with precise classification
            for (let i = 3; i < prices.length; i++) {
                const p = prices[i];
                const prev = prices[i-1];
                const bodySize = Math.abs(p.close - p.open);
                const totalSize = p.high - p.low;
                
                if (totalSize > 0 && bodySize / totalSize < 0.1) {
                    // Determine doji type
                    const upperShadow = p.high - Math.max(p.open, p.close);
                    const lowerShadow = Math.min(p.open, p.close) - p.low;
                    let dojiType = "Standard";
                    
                    // Dragonfly: small body at the top with long lower shadow
                    if (upperShadow / totalSize < 0.1 && lowerShadow / totalSize > 0.6) {
                        dojiType = "Dragonfly";
                    }
                    // Gravestone: small body at the bottom with long upper shadow
                    else if (lowerShadow / totalSize < 0.1 && upperShadow / totalSize > 0.6) {
                        dojiType = "Gravestone";
                    }
                    // Long-legged: significant shadows on both sides
                    else if (upperShadow / totalSize > 0.25 && lowerShadow / totalSize > 0.25) {
                        dojiType = "Long-legged";
                    }
                    
                    // Context-based signal for each doji type
                    let dojiSignal = 'neutral';
                    let dojiStrength = 0.65;
                    
                    // Determine prior trend direction (5 candles)
                    let priorTrend = 0;
                    for (let j = i-5; j < i; j++) {
                        if (j >= 0) {
                            priorTrend += (prices[j].close > prices[j].open) ? 1 : -1;
                        }
                    }
                    
                    // Strong trend context increases doji importance
                    if (Math.abs(priorTrend) >= 3) {
                        dojiStrength += 0.1;
                        
                        // Dragonfly doji is bullish at bottom of downtrend
                        if (dojiType === 'Dragonfly' && priorTrend < 0) {
                            dojiSignal = 'buy';
                            dojiStrength += 0.1;
                        }
                        // Gravestone doji is bearish at top of uptrend
                        else if (dojiType === 'Gravestone' && priorTrend > 0) {
                            dojiSignal = 'sell';
                            dojiStrength += 0.1;
                        }
                        // Standard doji is reversal signal at trend extremes
                        else if (dojiType === 'Standard') {
                            dojiSignal = priorTrend > 0 ? 'sell' : 'buy';
                        }
                    }
                    
                    // Special case: doji after long candle is stronger signal
                    if (i > 0) {
                        const prevBodySize = Math.abs(prev.close - prev.open);
                        const prevTotalSize = prev.high - prev.low;
                        
                        if (prevTotalSize > 0 && prevBodySize / prevTotalSize > 0.6) {
                            dojiStrength += 0.1;
                            
                            // Doji after bullish candle may be bearish
                            if (prev.close > prev.open) {
                                dojiSignal = 'sell';
                            }
                            // Doji after bearish candle may be bullish
                            else if (prev.close < prev.open) {
                                dojiSignal = 'buy';
                            }
                        }
                    }
                    
                    patterns.push({
                        name: `${dojiType} Doji`,
                        position: i,
                        signal: dojiSignal,
                        strength: dojiStrength
                    });
                }
            }
            
            return patterns;
        }

        // Improved function to find swing highs (peaks)
        function findSwingHighs(prices, lookback) {
            const swingHighs = [];
            
            for (let i = lookback; i < prices.length - lookback; i++) {
                let isSwingHigh = true;
                
                for (let j = i - lookback; j < i; j++) {
                    if (prices[j].high >= prices[i].high) {
                        isSwingHigh = false;
                        break;
                    }
                }
                
                if (isSwingHigh) {
                    for (let j = i + 1; j <= i + lookback; j++) {
                        if (j < prices.length && prices[j].high >= prices[i].high) {
                            isSwingHigh = false;
                            break;
                        }
                    }
                }
                
                if (isSwingHigh) {
                    swingHighs.push({
                        index: i,
                        value: prices[i].high
                    });
                }
            }
            
            return swingHighs;
        }

        // Find swing lows (valleys)
        function findSwingLows(prices, lookback) {
            const swingLows = [];
            
            for (let i = lookback; i < prices.length - lookback; i++) {
                let isSwingLow = true;
                
                for (let j = i - lookback; j < i; j++) {
                    if (prices[j].low <= prices[i].low) {
                        isSwingLow = false;
                        break;
                    }
                }
                
                if (isSwingLow) {
                    for (let j = i + 1; j <= i + lookback; j++) {
                        if (j < prices.length && prices[j].low <= prices[i].low) {
                            isSwingLow = false;
                            break;
                        }
                    }
                }
                
                if (isSwingLow) {
                    swingLows.push({
                        index: i,
                        value: prices[i].low
                    });
                }
            }
            
            return swingLows;
        }

        // Calculate Exponential Moving Average with validation
        function calculateEMA(prices, period) {
            if (!prices || prices.length < period) {
                return null;
            }
            
            try {
                const k = 2 / (period + 1);
                let ema = prices.slice(0, period).reduce((sum, price) => sum + price, 0) / period;
                
                for (let i = period; i < prices.length; i++) {
                    ema = (prices[i] * k) + (ema * (1 - k));
                }
                
                return ema;
            } catch (error) {
                console.error("Error calculating EMA:", error);
                return null;
            }
        }

        // Calculate MACD with enhanced error handling
        function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            try {
                if (!prices || prices.length < slowPeriod + signalPeriod) {
                    return { line: 0, signal: 0, histogram: 0, histogramPrev: 0 };
                }
                
                const fastEMA = calculateEMA(prices, fastPeriod) || 0;
                const slowEMA = calculateEMA(prices, slowPeriod) || 0;
                const macdLine = fastEMA - slowEMA;
                
                // Calculate signal line (EMA of MACD line)
                const macdValues = [];
                for (let i = prices.length - signalPeriod * 2; i < prices.length; i++) {
                    if (i >= 0) {
                        const fast = calculateEMA(prices.slice(0, i + 1), fastPeriod) || 0;
                        const slow = calculateEMA(prices.slice(0, i + 1), slowPeriod) || 0;
                        macdValues.push(fast - slow);
                    }
                }
                
                const signalLine = calculateEMA(macdValues, signalPeriod) || 0;
                const histogram = macdLine - signalLine;
                
                // Calculate previous histogram for trend direction
                const prevFastEMA = calculateEMA(prices.slice(0, prices.length - 1), fastPeriod) || 0;
                const prevSlowEMA = calculateEMA(prices.slice(0, prices.length - 1), slowPeriod) || 0;
                const prevMacdLine = prevFastEMA - prevSlowEMA;
                
                const prevMacdValues = macdValues.slice(0, -1);
                const prevSignalLine = calculateEMA(prevMacdValues, signalPeriod) || 0;
                const histogramPrev = prevMacdLine - prevSignalLine;
                
                return {
                    line: macdLine,
                    signal: signalLine,
                    histogram: histogram,
                    histogramPrev: histogramPrev
                };
            } catch (error) {
                console.error("Error calculating MACD:", error);
                return { line: 0, signal: 0, histogram: 0, histogramPrev: 0 };
            }
        }

        // Calculate RSI (Relative Strength Index) with error handling
        function calculateRSI(prices, period = 14) {
            try {
                if (!prices || prices.length < period + 1) {
                    return 50; // Default neutral value
                }
                
                let gains = 0;
                let losses = 0;
                
                for (let i = 1; i <= period; i++) {
                    const change = prices[prices.length - i] - prices[prices.length - i - 1];
                    if (change >= 0) {
                        gains += change;
                    } else {
                        losses -= change;
                    }
                }
                
                if (losses === 0) return 100;
                
                const rs = gains / losses;
                return 100 - (100 / (1 + rs));
            } catch (error) {
                console.error("Error calculating RSI:", error);
                return 50;
            }
        }

        // Calculate Bollinger Bands
        function calculateBollingerBands(prices, period = 20, multiplier = 2) {
            try {
                if (!prices || prices.length < period) {
                    return { upper: null, middle: null, lower: null };
                }
                
                const sma = prices.slice(prices.length - period).reduce((sum, price) => sum + price, 0) / period;
                
                // Calculate standard deviation
                const squaredDiffs = prices.slice(prices.length - period).map(price => Math.pow(price - sma, 2));
                const variance = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / period;
                const stdDev = Math.sqrt(variance);
                
                return {
                    upper: sma + (multiplier * stdDev),
                    middle: sma,
                    lower: sma - (multiplier * stdDev)
                };
            } catch (error) {
                console.error("Error calculating Bollinger Bands:", error);
                return { upper: 0, middle: 0, lower: 0 };
            }
        }

        // Enhanced Market Trend Analysis
        function analyzeMarketTrend(candles) {
            try {
                if (!candles || candles.length < 20) {
                    return { trend: 'neutral', strength: 0.5 };
                }
                
                const prices = candles.map(candle => ({
                    open: parseFloat(candle.mid.o),
                    high: parseFloat(candle.mid.h),
                    low: parseFloat(candle.mid.l),
                    close: parseFloat(candle.mid.c),
                    volume: Math.abs(parseFloat(candle.mid.h) - parseFloat(candle.mid.l))
                }));
                
                const closePrices = prices.map(price => price.close);
                
                // Calculate various indicators with error handling
                const ema9 = calculateEMA(closePrices, 9) || closePrices[closePrices.length - 1];
                const ema20 = calculateEMA(closePrices, 20) || closePrices[closePrices.length - 1];
                const ema50 = calculateEMA(closePrices, 50) || closePrices[closePrices.length - 1];
                const ema200 = candles.length >= 220 ? calculateEMA(closePrices, 200) || closePrices[closePrices.length - 1] : null;
                
                // Calculate MACD
                const macd = calculateMACD(closePrices);
                
                // Calculate RSI
                const rsi = calculateRSI(closePrices);
                
                // Calculate Bollinger Bands
                const bollingerBands = calculateBollingerBands(closePrices, 20, 2);
                
                // Identify swing points for market structure analysis
                const swingHighs = findSwingHighs(prices, 5);
                const swingLows = findSwingLows(prices, 5);
                
                // Analyze higher highs/higher lows patterns
                let higherHighs = false;
                let higherLows = false;
                let lowerHighs = false;
                let lowerLows = false;
                
                if (swingHighs.length >= 3) {
                    // Require at least 3 consecutive higher highs for reliable pattern
                    higherHighs = swingHighs[swingHighs.length-1].value > swingHighs[swingHighs.length-2].value && 
                                swingHighs[swingHighs.length-2].value > swingHighs[swingHighs.length-3].value;
                                
                    lowerHighs = swingHighs[swingHighs.length-1].value < swingHighs[swingHighs.length-2].value && 
                                swingHighs[swingHighs.length-2].value < swingHighs[swingHighs.length-3].value;
                }
                
                if (swingLows.length >= 3) {
                    // Require at least 3 consecutive higher lows for reliable pattern
                    higherLows = swingLows[swingLows.length-1].value > swingLows[swingLows.length-2].value && 
                                swingLows[swingLows.length-2].value > swingLows[swingLows.length-3].value;
                                
                    lowerLows = swingLows[swingLows.length-1].value < swingLows[swingLows.length-2].value && 
                                swingLows[swingLows.length-2].value < swingLows[swingLows.length-3].value;
                }
                
                // Current price
                const currentPrice = closePrices[closePrices.length - 1];
                
                // Enhanced trend score calculation
                let trendScore = 0;
                
                // Price vs EMAs with higher weight on longer-term EMAs
                trendScore += currentPrice > ema9 ? 1 : -1;
                trendScore += currentPrice > ema20 ? 2 : -2;
                trendScore += currentPrice > ema50 ? 3 : -3;
                if (ema200 !== null) trendScore += currentPrice > ema200 ? 4 : -4;
                
                // EMA alignment
                const emaUptrend = ema9 > ema20 && ema20 > ema50 && (ema200 ? ema50 > ema200 : true);
                const emaDowntrend = ema9 < ema20 && ema20 < ema50 && (ema200 ? ema50 < ema200 : true);
                
                trendScore += emaUptrend ? 3 : 0;
                trendScore += emaDowntrend ? -3 : 0;
                
                // MACD
                trendScore += macd.histogram > 0 ? 2 : -2;
                trendScore += macd.histogram > macd.histogramPrev ? 1 : -1;
                
                // Higher scoring for established price patterns
                trendScore += (higherHighs && higherLows) ? 4 : 0;
                trendScore += (lowerHighs && lowerLows) ? -4 : 0;
                
                // RSI weighting
                if (rsi > 70) trendScore -= 2; // Overbought
                else if (rsi > 60) trendScore += 2; // Strong but not overbought
                else if (rsi < 30) trendScore += 2; // Oversold
                else if (rsi < 40) trendScore -= 2; // Weak but not oversold
                
                // Determine final trend direction
                let trendDirection = 'neutral';
                let trendStrength = 0.5;
                
                const maxScore = ema200 !== null ? 20 : 16; // Maximum possible score
                const normalizedScore = trendScore / maxScore;
                
                if (normalizedScore > 0.25) {
                    trendDirection = 'bullish';
                    trendStrength = Math.min(0.5 + normalizedScore, 0.95);
                } else if (normalizedScore < -0.25) {
                    trendDirection = 'bearish';
                    trendStrength = Math.min(0.5 + Math.abs(normalizedScore), 0.95);
                } else {
                    // Near-neutral zone
                    trendDirection = 'neutral';
                    trendStrength = 0.5 - Math.abs(normalizedScore) * 0.5;
                }
                
                // Bollinger band analysis
                const bandWidth = bollingerBands.upper && bollingerBands.middle ? 
                    (bollingerBands.upper - bollingerBands.lower) / bollingerBands.middle : 0.05;
                const isBollingerSqueeze = bandWidth < 0.03; // 3% or less
                
                // Adjust for Bollinger squeeze (lower confidence in squeeze conditions)
                if (isBollingerSqueeze) {
                    trendStrength *= 0.85;
                }
                
                return {
                    trend: trendDirection,
                    strength: Math.max(Math.min(trendStrength, 0.95), 0.1), // Ensure between 0.1 and 0.95
                    details: {
                        ema9,
                        ema20,
                        ema50,
                        ema200,
                        macd: macd.histogram,
                        rsi,
                        bollingerWidth: bandWidth,
                        isBollingerSqueeze
                    },
                    signals: {
                        emaAlignment: emaUptrend ? 'bullish' : (emaDowntrend ? 'bearish' : 'neutral'),
                        priceVsEma: currentPrice > ema50 ? 'bullish' : 'bearish',
                        macdSignal: macd.histogram > 0 ? 'bullish' : 'bearish',
                        swingPattern: (higherHighs && higherLows) ? 'bullish' : 
                                    ((lowerHighs && lowerLows) ? 'bearish' : 'neutral'),
                        overboughtOversold: rsi > 70 ? 'overbought' : (rsi < 30 ? 'oversold' : 'neutral')
                    }
                };
            } catch (error) {
                console.error("Error in market trend analysis:", error);
                // Return default values if error occurs
                return { 
                    trend: 'neutral', 
                    strength: 0.5,
                    details: {
                        rsi: 50,
                        macd: 0
                    },
                    signals: {
                        emaAlignment: 'neutral',
                        priceVsEma: 'neutral',
                        macdSignal: 'neutral',
                        swingPattern: 'neutral',
                        overboughtOversold: 'neutral'
                    }
                };
            }
        }

        // Identify Support and Resistance Levels
        function findSupportResistance(candles, levels = 5) {
            try {
                if (!candles || candles.length < 30) {
                    return { support: [], resistance: [] };
                }
                
                const prices = candles.map(candle => ({
                    high: parseFloat(candle.mid.h),
                    low: parseFloat(candle.mid.l),
                    close: parseFloat(candle.mid.c),
                    open: parseFloat(candle.mid.o)
                }));
                
                // Collect all price points
                const pricePoints = [];
                
                prices.forEach(price => {
                    pricePoints.push(price.high);
                    pricePoints.push(price.low);
                });
                
                // Sort price points
                pricePoints.sort((a, b) => a - b);
                
                // Find clusters - prices that are very close to each other
                const clusters = [];
                let currentCluster = [pricePoints[0]];
                
                const threshold = (pricePoints[pricePoints.length - 1] - pricePoints[0]) * 0.0015; // 0.15% of price range
                
                for (let i = 1; i < pricePoints.length; i++) {
                    if (pricePoints[i] - pricePoints[i-1] < threshold) {
                        currentCluster.push(pricePoints[i]);
                    } else {
                        if (currentCluster.length > 3) {
                            // Only consider clusters with at least 3 price points
                            clusters.push(currentCluster);
                        }
                        currentCluster = [pricePoints[i]];
                    }
                }
                
                // Add the last cluster if it's significant
                if (currentCluster.length > 3) {
                    clusters.push(currentCluster);
                }
                
                // Calculate average price for each cluster and count touches
                const levelData = clusters.map(cluster => {
                    const avgPrice = cluster.reduce((sum, price) => sum + price, 0) / cluster.length;
                    
                    // Count how many times prices approached this level
                    let touchCount = 0;
                    for (let i = 1; i < prices.length - 1; i++) {
                        // Check if price approached from above
                        if (Math.abs(prices[i].low - avgPrice) / avgPrice < 0.0015) {
                            touchCount++;
                        }
                        // Check if price approached from below
                        else if (Math.abs(prices[i].high - avgPrice) / avgPrice < 0.0015) {
                            touchCount++;
                        }
                    }
                    
                    return {
                        price: avgPrice,
                        strength: 0.5 + Math.min(0.4, touchCount * 0.05), // More touches = stronger level
                        touches: touchCount,
                        size: cluster.length
                    };
                });
                
                // Sort by strength
                const sortedLevels = levelData.sort((a, b) => b.strength - a.strength);
                
                // Current price
                const currentPrice = prices[prices.length - 1].close;
                
                // Split into support and resistance
                const support = sortedLevels
                    .filter(level => level.price < currentPrice)
                    .slice(0, levels)
                    .map(level => ({
                        price: level.price.toFixed(5),
                        strength: level.strength,
                        touches: level.touches
                    }));
                
                const resistance = sortedLevels
                    .filter(level => level.price > currentPrice)
                    .slice(0, levels)
                    .map(level => ({
                        price: level.price.toFixed(5),
                        strength: level.strength,
                        touches: level.touches
                    }));
                
                return { support, resistance };
            } catch (error) {
                console.error("Error finding support/resistance:", error);
                return { support: [], resistance: [] };
            }
        }

        // Detect divergences between price and indicators
        function detectDivergences(prices, timeframe) {
            try {
                if (!prices || prices.length < 30) return [];
                
                const divergences = [];
                const closePrices = prices.map(price => price.close);
                
                // Calculate RSI values
                const rsiValues = [];
                for (let i = 14; i < closePrices.length; i++) {
                    const window = closePrices.slice(i - 14, i + 1);
                    rsiValues.push(calculateRSI(window));
                }
                
                // Find price swing highs/lows
                const swingHighs = findSwingHighs(prices, 5);
                const swingLows = findSwingLows(prices, 5);
                
                // Find RSI swing highs/lows (with offset for calculation)
                const rsiSwingHighs = [];
                const rsiSwingLows = [];
                
                for (let i = 5; i < rsiValues.length - 5; i++) {
                    let isHigh = true;
                    let isLow = true;
                    
                    for (let j = i - 5; j < i; j++) {
                        if (j >= 0 && rsiValues[j] >= rsiValues[i]) isHigh = false;
                        if (j >= 0 && rsiValues[j] <= rsiValues[i]) isLow = false;
                    }
                    
                    for (let j = i + 1; j <= i + 5; j++) {
                        if (j < rsiValues.length) {
                            if (rsiValues[j] >= rsiValues[i]) isHigh = false;
                            if (rsiValues[j] <= rsiValues[i]) isLow = false;
                        }
                    }
                    
                    if (isHigh) {
                        rsiSwingHighs.push({
                            index: i + 14, // Adjust index to match price data
                            value: rsiValues[i]
                        });
                    }
                    
                    if (isLow) {
                        rsiSwingLows.push({
                            index: i + 14, // Adjust index to match price data
                            value: rsiValues[i]
                        });
                    }
                }
                
                // Detect bearish divergence (price higher high, RSI lower high)
                if (swingHighs.length >= 2 && rsiSwingHighs.length >= 2) {
                    const recentPriceHigh = swingHighs[swingHighs.length - 1];
                    const previousPriceHigh = swingHighs[swingHighs.length - 2];
                    
                    const recentRsiHigh = rsiSwingHighs[rsiSwingHighs.length - 1];
                    const previousRsiHigh = rsiSwingHighs[rsiSwingHighs.length - 2];
                    
                    // Check if price made higher high but RSI made lower high
                    if (recentPriceHigh.value > previousPriceHigh.value && 
                        recentRsiHigh.value < previousRsiHigh.value &&
                        Math.abs(recentPriceHigh.index - recentRsiHigh.index) < 3) {
                        
                        divergences.push({
                            type: 'Bearish Divergence',
                            timeframe: timeframe,
                            strength: 0.85,
                            signal: 'sell'
                        });
                    }
                }
                
                // Detect bullish divergence (price lower low, RSI higher low)
                if (swingLows.length >= 2 && rsiSwingLows.length >= 2) {
                    const recentPriceLow = swingLows[swingLows.length - 1];
                    const previousPriceLow = swingLows[swingLows.length - 2];
                    
                    const recentRsiLow = rsiSwingLows[rsiSwingLows.length - 1];
                    const previousRsiLow = rsiSwingLows[rsiSwingLows.length - 2];
                    
                    // Check if price made lower low but RSI made higher low
                    if (recentPriceLow.value < previousPriceLow.value && 
                        recentRsiLow.value > previousRsiLow.value &&
                        Math.abs(recentPriceLow.index - recentRsiLow.index) < 3) {
                        
                        divergences.push({
                            type: 'Bullish Divergence',
                            timeframe: timeframe,
                            strength: 0.85,
                            signal: 'buy'
                        });
                    }
                }
                
                return divergences;
            } catch (error) {
                console.error("Error detecting divergences:", error);
                return [];
            }
        }

        // Analyze market context for better decision making
        function analyzeMarketContext(candles1h, candles15m, candles5m, candles1m) {
            try {
                // Return if any dataset is missing
                if (!candles1h || !candles15m || !candles5m || !candles1m) {
                    return { context: 'neutral', confidence: 0.5 };
                }
                
                // Extract prices
                const prices1h = candles1h.map(candle => ({
                    open: parseFloat(candle.mid.o),
                    high: parseFloat(candle.mid.h),
                    low: parseFloat(candle.mid.l),
                    close: parseFloat(candle.mid.c)
                }));
                
                const prices15m = candles15m.map(candle => ({
                    open: parseFloat(candle.mid.o),
                    high: parseFloat(candle.mid.h),
                    low: parseFloat(candle.mid.l),
                    close: parseFloat(candle.mid.c)
                }));
                
                // Current price
                const currentPrice = prices15m[prices15m.length - 1].close;
                
                // Analyze daily range
                const dayHighest = Math.max(...prices1h.slice(-24).map(p => p.high));
                const dayLowest = Math.min(...prices1h.slice(-24).map(p => p.low));
                const dayRange = dayHighest - dayLowest;
                const positionInRange = (currentPrice - dayLowest) / dayRange;
                
                // Market structure: Higher highs/lows vs Lower highs/lows
                const structure1h = analyzeMarketStructure(prices1h);
                const structure15m = analyzeMarketStructure(prices15m);
                
                // Analyze combined context
                let contextScore = 0;
                let contextConfidence = 0.5;
                
                // Position in daily range
                if (positionInRange > 0.7) contextScore -= 2; // Near top of range
                else if (positionInRange < 0.3) contextScore += 2; // Near bottom of range
                
                // Market structure contribution
                contextScore += structure1h === 'uptrend' ? 3 : (structure1h === 'downtrend' ? -3 : 0);
                contextScore += structure15m === 'uptrend' ? 2 : (structure15m === 'downtrend' ? -2 : 0);
                
                // Determine context
                let marketContext = 'neutral';
                if (contextScore > 3) marketContext = 'bullish';
                else if (contextScore < -3) marketContext = 'bearish';
                
                return {
                    context: marketContext,
                    confidence: Math.min(Math.max(contextConfidence, 0.4), 0.9),
                    details: {
                        positionInRange: positionInRange.toFixed(2),
                        structure1h,
                        structure15m,
                        isRangebound: isRangeMarket(prices1h),
                        volatility1h: calculateVolatility(prices1h).toFixed(4),
                        volatility15m: calculateVolatility(prices15m).toFixed(4)
                    }
                };
            } catch (error) {
                console.error("Error analyzing market context:", error);
                return { 
                    context: 'neutral', 
                    confidence: 0.5,
                    details: {
                        isRangebound: false,
                        volatility15m: '0.0050'
                    }
                };
            }
        }

        // Analyze market structure for higher highs/lows or lower highs/lows
        function analyzeMarketStructure(prices) {
            try {
                if (prices.length < 20) return 'neutral';
                
                const swingHighs = findSwingHighs(prices, 5);
                const swingLows = findSwingLows(prices, 5);
                
                // Need at least two swing points to determine structure
                if (swingHighs.length < 2 || swingLows.length < 2) return 'neutral';
                
                // Check last two swing highs and lows
                const lastHigh = swingHighs[swingHighs.length - 1];
                const prevHigh = swingHighs[swingHighs.length - 2];
                
                const lastLow = swingLows[swingLows.length - 1];
                const prevLow = swingLows[swingLows.length - 2];
                
                const higherHighs = lastHigh.value > prevHigh.value;
                const higherLows = lastLow.value > prevLow.value;
                const lowerHighs = lastHigh.value < prevHigh.value;
                const lowerLows = lastLow.value < prevLow.value;
                
                if (higherHighs && higherLows) return 'uptrend';
                if (lowerHighs && lowerLows) return 'downtrend';
                
                // Mixed signals
                if (higherHighs && lowerLows) return 'choppy';
                if (lowerHighs && higherLows) return 'contracting';
                
                return 'neutral';
            } catch (error) {
                console.error("Error analyzing market structure:", error);
                return 'neutral';
            }
        }

        // Detect ranging market
        function isRangeMarket(prices, threshold = 0.003) {
            try {
                if (prices.length < 20) return false;
                
                // Check last 20 candles
                const recentPrices = prices.slice(-20);
                
                // Calculate average range
                const highest = Math.max(...recentPrices.map(p => p.high));
                const lowest = Math.min(...recentPrices.map(p => p.low));
                
                // Calculate range as percentage of average price
                const avgPrice = (highest + lowest) / 2;
                const rangePercent = (highest - lowest) / avgPrice;
                
                // Check if most prices are contained within a narrow band
                const midPrice = (highest + lowest) / 2;
                const narrowBandCount = recentPrices.filter(p => 
                    Math.abs(p.close - midPrice) / midPrice < threshold
                ).length;
                
                // Range criteria: narrow overall range and most prices clustered
                return rangePercent < 0.015 && narrowBandCount > 12;
            } catch (error) {
                console.error("Error detecting range market:", error);
                return false;
            }
        }

        // Calculate volatility
        function calculateVolatility(prices, period = 14) {
            try {
                if (!prices || prices.length < period) return 0.001; // Default value
                
                const closePrices = prices.map(price => price.close);
                const returns = [];
                
                for (let i = 1; i < closePrices.length; i++) {
                    returns.push((closePrices[i] / closePrices[i-1]) - 1);
                }
                
                // Calculate standard deviation of returns
                const mean = returns.reduce((sum, val) => sum + val, 0) / returns.length;
                const squaredDiffs = returns.map(val => Math.pow(val - mean, 2));
                const variance = squaredDiffs.reduce((sum, val) => sum + val, 0) / squaredDiffs.length;
                
                return Math.sqrt(variance);
            } catch (error) {
                console.error("Error calculating volatility:", error);
                return 0.001; // Default value
            }
        }

        // Calculate pattern strength from multiple timeframes
        function calculatePatternStrength(patterns1h, patterns15m, patterns5m, signalType) {
            try {
                let strength = 0;
                
                // More weight to larger timeframes and recent patterns
                patterns1h.forEach((pattern, index) => {
                    if (pattern.signal === signalType) {
                        strength += pattern.strength * 3 * (1 - index * 0.1);
                    }
                });
                
                patterns15m.forEach((pattern, index) => {
                    if (pattern.signal === signalType) {
                        strength += pattern.strength * 2 * (1 - index * 0.1);
                    }
                });
                
                patterns5m.forEach((pattern, index) => {
                    if (pattern.signal === signalType) {
                        strength += pattern.strength * 1 * (1 - index * 0.1);
                    }
                });
                
                return Math.min(strength, 10) / 10; // Normalize to 0-1
            } catch (error) {
                console.error("Error calculating pattern strength:", error);
                return 0.5;
            }
        }

        // Get most relevant patterns for display
        function getRelevantPatterns(allPatterns) {
            try {
                // Sort by strength and recency
                const sortedPatterns = allPatterns
                    .sort((a, b) => b.strength - a.strength)
                    .slice(0, 3)
                    .map(p => p.name);
                
                return sortedPatterns.length > 0 ? sortedPatterns[0] : "None";
            } catch (error) {
                console.error("Error getting relevant patterns:", error);
                return "None";
            }
        }

        // Calculate timeframe alignment score
        function calculateTimeframeAlignment(trend1h, trend15m, trend5m, trend1m) {
            try {
                let alignmentScore = 0;
                
                // Count alignments
                if (trend1h === trend15m) alignmentScore++;
                if (trend15m === trend5m) alignmentScore++;
                if (trend5m === trend1m) alignmentScore++;
                
                // Check if all align
                if (trend1h === trend15m && trend15m === trend5m && trend5m === trend1m) {
                    return trend1h === 'bullish' ? 'strong_bullish' : 
                          trend1h === 'bearish' ? 'strong_bearish' : 'neutral';
                }
                
                // Check if 3 out of 4 align
                if (alignmentScore >= 2) {
                    // Determine dominant trend
                    let bullCount = 0;
                    let bearCount = 0;
                    
                    [trend1h, trend15m, trend5m, trend1m].forEach(trend => {
                        if (trend === 'bullish') bullCount++;
                        if (trend === 'bearish') bearCount++;
                    });
                    
                    if (bullCount >= 3) return 'moderate_bullish';
                    if (bearCount >= 3) return 'moderate_bearish';
                }
                
                // Mixed signals
                return 'mixed';
            } catch (error) {
                console.error("Error calculating timeframe alignment:", error);
                return 'mixed';
            }
        }

        // Improved advanced decision model with better accuracy
        function advancedDecisionModel(features) {
            try {
                // Signal strength variables
                let buySignalStrength = 0;
                let sellSignalStrength = 0;
                const reasons = [];
                
                // 1. Trend Analysis with refined weighting
                if (features.trend1h === 'bullish') {
                    const strength = 3 * features.trendStrength1h;
                    buySignalStrength += strength;
                    
                    if (features.trendStrength1h > 0.7) {
                        reasons.push("Strong bullish trend on 1-hour timeframe");
                    } else {
                        reasons.push("1-hour timeframe shows bullish trend");
                    }
                } else if (features.trend1h === 'bearish') {
                    const strength = 3 * features.trendStrength1h;
                    sellSignalStrength += strength;
                    
                    if (features.trendStrength1h > 0.7) {
                        reasons.push("Strong bearish trend on 1-hour timeframe");
                    } else {
                        reasons.push("1-hour timeframe shows bearish trend");
                    }
                }
                
                if (features.trend15m === 'bullish') {
                    const strength = 2.2 * features.trendStrength15m;
                    buySignalStrength += strength;
                    reasons.push("15-minute timeframe shows bullish trend");
                } else if (features.trend15m === 'bearish') {
                    const strength = 2.2 * features.trendStrength15m;
                    sellSignalStrength += strength;
                    reasons.push("15-minute timeframe shows bearish trend");
                }
                
                if (features.trend5m === 'bullish') {
                    buySignalStrength += 1.2;
                } else if (features.trend5m === 'bearish') {
                    sellSignalStrength += 1.2;
                }
                
                if (features.trend1m === 'bullish') {
                    buySignalStrength += 0.7;
                } else if (features.trend1m === 'bearish') {
                    sellSignalStrength += 0.7;
                }
                
                // 2. Timeframe Alignment - enhanced weighting for strong alignment
                if (features.timeframeAlignment === 'strong_bullish') {
                    buySignalStrength += 5.5;
                    reasons.push("Strong bullish alignment across all timeframes");
                } else if (features.timeframeAlignment === 'strong_bearish') {
                    sellSignalStrength += 5.5;
                    reasons.push("Strong bearish alignment across all timeframes");
                } else if (features.timeframeAlignment === 'moderate_bullish') {
                    buySignalStrength += 3.5;
                    reasons.push("Moderate bullish alignment across multiple timeframes");
                } else if (features.timeframeAlignment === 'moderate_bearish') {
                    sellSignalStrength += 3.5;
                    reasons.push("Moderate bearish alignment across multiple timeframes");
                }
                
                // 3. Enhanced Pattern Analysis with higher impact for stronger patterns
                if (features.bullishPatternStrength > 0.75) {
                    const strength = features.bullishPatternStrength * 4.5;
                    buySignalStrength += strength;
                    reasons.push(`Strong bullish patterns detected (${(features.bullishPatternStrength * 100).toFixed(0)}% strength)`);
                } else if (features.bullishPatternStrength > 0.5) {
                    const strength = features.bullishPatternStrength * 3;
                    buySignalStrength += strength;
                    reasons.push(`Bullish patterns detected (${(features.bullishPatternStrength * 100).toFixed(0)}% strength)`);
                } else if (features.bullishPatternStrength > 0.3) {
                    buySignalStrength += features.bullishPatternStrength * 2;
                }
                
                if (features.bearishPatternStrength > 0.75) {
                    const strength = features.bearishPatternStrength * 4.5;
                    sellSignalStrength += strength;
                    reasons.push(`Strong bearish patterns detected (${(features.bearishPatternStrength * 100).toFixed(0)}% strength)`);
                } else if (features.bearishPatternStrength > 0.5) {
                    const strength = features.bearishPatternStrength * 3;
                    sellSignalStrength += strength;
                    reasons.push(`Bearish patterns detected (${(features.bearishPatternStrength * 100).toFixed(0)}% strength)`);
                } else if (features.bearishPatternStrength > 0.3) {
                    sellSignalStrength += features.bearishPatternStrength * 2;
                }
                
                // 4. Divergence Signals (strong reversal signals)
                if (features.bullishDivergence) {
                    buySignalStrength += 4.5;
                    reasons.push("Bullish divergence detected (strong reversal signal)");
                }
                
                if (features.bearishDivergence) {
                    sellSignalStrength += 4.5;
                    reasons.push("Bearish divergence detected (strong reversal signal)");
                }
                
                // 5. Volume Analysis
                if (features.volumeTrend1h === 'bullish') {
                    buySignalStrength += 2.5;
                    reasons.push("Bullish volume profile on 1-hour timeframe");
                } else if (features.volumeTrend1h === 'bearish') {
                    sellSignalStrength += 2.5;
                    reasons.push("Bearish volume profile on 1-hour timeframe");
                }
                
                if (features.volumeTrend15m === 'bullish') {
                    buySignalStrength += 1.5;
                } else if (features.volumeTrend15m === 'bearish') {
                    sellSignalStrength += 1.5;
                }
                
                // 6. Support/Resistance Proximity
                if (features.hasCloseSupport) {
                    const strength = 2.5 * features.supportStrength;
                    buySignalStrength += strength;
                    reasons.push("Price near significant support level");
                }
                
                if (features.hasCloseResistance) {
                    const strength = 2.5 * features.resistanceStrength;
                    sellSignalStrength += strength;
                    reasons.push("Price near significant resistance level");
                }
                
                // 7. Pattern/Level Confluence
                if (features.patternLevelConfluence === 'high') {
                    // Amplify the stronger signal
                    if (buySignalStrength > sellSignalStrength) {
                        buySignalStrength += 3.5;
                        reasons.push("High confluence between bullish patterns and support levels");
                    } else {
                        sellSignalStrength += 3.5;
                        reasons.push("High confluence between bearish patterns and resistance levels");
                    }
                } else if (features.patternLevelConfluence === 'medium') {
                    // Amplify the stronger signal
                    if (buySignalStrength > sellSignalStrength) {
                        buySignalStrength += 2;
                    } else {
                        sellSignalStrength += 2;
                    }
                }
                
                // 8. Market Context
                if (features.marketContext === 'bullish') {
                    buySignalStrength += 2.5;
                    reasons.push("Overall market context is bullish");
                } else if (features.marketContext === 'bearish') {
                    sellSignalStrength += 2.5;
                    reasons.push("Overall market context is bearish");
                }
                
                // 9. Risk/Reward Consideration
                if (features.riskRewardRatio > 3) {
                    buySignalStrength += 3;
                    reasons.push(`Excellent risk/reward ratio for buying (${features.riskRewardRatio.toFixed(1)}:1)`);
                } else if (features.riskRewardRatio > 2) {
                    buySignalStrength += 2;
                    reasons.push(`Favorable risk/reward ratio for buying (${features.riskRewardRatio.toFixed(1)}:1)`);
                } else if (features.riskRewardRatio < 0.33) {
                    sellSignalStrength += 3;
                    reasons.push(`Excellent risk/reward ratio for selling (${(1/features.riskRewardRatio).toFixed(1)}:1)`);
                } else if (features.riskRewardRatio < 0.5) {
                    sellSignalStrength += 2;
                    reasons.push(`Favorable risk/reward ratio for selling (${(1/features.riskRewardRatio).toFixed(1)}:1)`);
                }
                
                // 10. Special Condition Adjustments
                
                // Range market adjustments
                if (features.isRangeMarket) {
                    // In range markets, reduce overall confidence
                    buySignalStrength *= 0.88;
                    sellSignalStrength *= 0.88;
                    
                    // In ranges, we want to fade the extremes
                    if (features.hasCloseResistance) {
                        sellSignalStrength *= 1.25;
                        reasons.push("Range market near resistance strongly favors selling");
                    }
                    
                    if (features.hasCloseSupport) {
                        buySignalStrength *= 1.25;
                        reasons.push("Range market near support strongly favors buying");
                    }
                }
                
                // High volatility adjustments
                if (features.isHighVolatility) {
                    // In high volatility, reduce confidence but maintain direction
                    const volatilityFactor = 0.85;
                    buySignalStrength *= volatilityFactor;
                    sellSignalStrength *= volatilityFactor;
                    reasons.push("High market volatility detected - using increased caution");
                    
                    // In high volatility, consider trend alignment more important
                    if (features.timeframeAlignment === 'strong_bullish') {
                        buySignalStrength *= 1.15;
                    } else if (features.timeframeAlignment === 'strong_bearish') {
                        sellSignalStrength *= 1.15;
                    }
                }
                
                // 11. Ultra Mode Adjustment
                if (features.ultraMode) {
                    // In ultra mode, we increase confidence when signals align well
                    const ultraBoostFactor = buySignalStrength > sellSignalStrength ? 
                        Math.min(1 + (buySignalStrength / (buySignalStrength + sellSignalStrength)) * 0.15, 1.15) :
                        Math.min(1 + (sellSignalStrength / (buySignalStrength + sellSignalStrength)) * 0.15, 1.15);
                    
                    if (buySignalStrength > sellSignalStrength) {
                        buySignalStrength *= ultraBoostFactor;
                    } else {
                        sellSignalStrength *= ultraBoostFactor;
                    }
                }
                
                // 12. Normalize and calculate final signal
                const totalSignalStrength = buySignalStrength + sellSignalStrength;
                
                // Avoid division by zero
                if (totalSignalStrength < 0.1) {
                    return {
                        signal: Math.random() < 0.5 ? 'buy' : 'sell', 
                        confidence: 0.67,
                        reasons: ["Insufficient clear signals - using probability model"]
                    };
                }
                
                // Calculate enhanced confidence with better scaling
                let baseConfidence = 0.67 + (Math.max(buySignalStrength, sellSignalStrength) / totalSignalStrength) * 0.28;
                
                // Apply ultra mode boost with more sophistication
                let finalConfidence = features.ultraMode ? 
                    Math.min(baseConfidence + 0.08 * Math.pow(Math.max(buySignalStrength, sellSignalStrength) / totalSignalStrength, 0.5), 0.97) : 
                    Math.min(baseConfidence, 0.89);
                
                // Handle very close calls with reduced confidence
                const signalDifferenceRatio = Math.abs(buySignalStrength - sellSignalStrength) / totalSignalStrength;
                
                if (signalDifferenceRatio < 0.15) {
                    const confidenceReduction = 0.15 * (1 - signalDifferenceRatio / 0.15);
                    finalConfidence = Math.max(finalConfidence - confidenceReduction, 0.67);
                    reasons.push("Mixed signals with no clear direction - reducing confidence");
                }
                
                // Special case: dominant reversal signals in counter-trend deserve caution
                if ((features.bullishDivergence && features.trend1h === 'bearish') || 
                    (features.bearishDivergence && features.trend1h === 'bullish')) {
                    finalConfidence = Math.max(finalConfidence - 0.07, 0.67);
                    reasons.push("Countertrend reversal signal - proceeding with caution");
                }
                
                // Round to 2 decimal places
                finalConfidence = Math.round(finalConfidence * 100) / 100;
                
                // Get top 3 reasons maximum
                const topReasons = reasons.slice(0, 3);
                
                // Return final decision
                return {
                    signal: buySignalStrength > sellSignalStrength ? 'buy' : 'sell',
                    confidence: finalConfidence,
                    reasons: topReasons
                };
            } catch (error) {
                console.error("Error in decision model:", error);
                // Return fallback signal if model fails
                return {
                    signal: Math.random() < 0.5 ? 'buy' : 'sell',
                    confidence: 0.67,
                    reasons: ["Signal calculated using fallback model"]
                };
            }
        }

        // Enhanced signal generation with all analysis features
        async function generateEnhancedSignal(pair, timeframe, ultraMode = false) {
            try {
                // Get candles for multiple timeframes for comprehensive analysis
                let candles1h, candles15m, candles5m, candles1m;
                
                try {
                    // Fetch data with error handling
                    candles1h = await fetchOandaData(pair, 'H1', 100);
                    candles15m = await fetchOandaData(pair, 'M15', 100);
                    candles5m = await fetchOandaData(pair, 'M5', 100);
                    candles1m = await fetchOandaData(pair, 'M1', 100);
                } catch (error) {
                    console.error("Error fetching candle data:", error);
                    // Generate simulated data if fetch fails
                    candles1h = generateSimulatedCandles('H1', 100);
                    candles15m = generateSimulatedCandles('M15', 100);
                    candles5m = generateSimulatedCandles('M5', 100);
                    candles1m = generateSimulatedCandles('M1', 100);
                }
                
                if (!candles1h || !candles15m || !candles5m || !candles1m) {
                    console.warn("Missing data for some timeframes. Using random signal as fallback.");
                    return { 
                        signal: Math.random() < 0.5 ? 'buy' : 'sell', 
                        confidence: 0.65,
                        analysis: {
                            trend: { dominant: 'neutral' },
                            patterns: { main: 'None' },
                            supportResistance: { support: 'N/A', resistance: 'N/A' },
                            indicators: { rsi: '50.00', macd: '0.00000' },
                            currentPrice: '0.00000'
                        }
                    };
                }
                
                // Validate and convert price data
                const prices1h = candles1h.map(candle => ({
                    open: parseFloat(candle.mid.o) || 0,
                    high: parseFloat(candle.mid.h) || 0,
                    low: parseFloat(candle.mid.l) || 0,
                    close: parseFloat(candle.mid.c) || 0,
                    volume: Math.abs(parseFloat(candle.mid.h) - parseFloat(candle.mid.l)) || 0.001
                }));
                
                const prices15m = candles15m.map(candle => ({
                    open: parseFloat(candle.mid.o) || 0,
                    high: parseFloat(candle.mid.h) || 0,
                    low: parseFloat(candle.mid.l) || 0,
                    close: parseFloat(candle.mid.c) || 0,
                    volume: Math.abs(parseFloat(candle.mid.h) - parseFloat(candle.mid.l)) || 0.001
                }));
                
                // Get current price with validation
                let currentPrice = parseFloat(candles1m[candles1m.length-1].mid.c);
                if (isNaN(currentPrice) || currentPrice <= 0) {
                    currentPrice = parseFloat(candles15m[candles15m.length-1].mid.c) || 1.0;
                }
                
                // Comprehensive pattern analysis
                const patterns1h = detectPatterns(candles1h);
                const patterns15m = detectPatterns(candles15m);
                const patterns5m = detectPatterns(candles5m);
                
                // Advanced trend analysis
                const trend1h = analyzeMarketTrend(candles1h);
                const trend15m = analyzeMarketTrend(candles15m);
                const trend5m = analyzeMarketTrend(candles5m);
                const trend1m = analyzeMarketTrend(candles1m);
                
                // Support/resistance analysis
                const sr1h = findSupportResistance(candles1h, 5);
                const sr15m = findSupportResistance(candles15m, 3);
                
                // Divergence detection
                const divergences1h = detectDivergences(prices1h, '1h');
                const divergences15m = detectDivergences(prices15m, '15m');
                
                // Market context analysis
                const marketContext = analyzeMarketContext(candles1h, candles15m, candles5m, candles1m);
                
                // Combine support/resistance from different sources
                const allSupportLevels = [
                    ...sr1h.support.map(level => ({
                        price: parseFloat(level.price) || 0,
                        strength: level.strength || 0.5,
                        type: 'Price Cluster',
                        timeframe: '1h'
                    })),
                    ...sr15m.support.map(level => ({
                        price: parseFloat(level.price) || 0,
                        strength: (level.strength || 0.5) * 0.9, // Slightly less weight
                        type: 'Price Cluster',
                        timeframe: '15m'
                    }))
                ].filter(level => level.price > 0 && level.price < currentPrice)
                 .sort((a, b) => b.price - a.price);
                
                const allResistanceLevels = [
                    ...sr1h.resistance.map(level => ({
                        price: parseFloat(level.price) || 0,
                        strength: level.strength || 0.5,
                        type: 'Price Cluster',
                        timeframe: '1h'
                    })),
                    ...sr15m.resistance.map(level => ({
                        price: parseFloat(level.price) || 0,
                        strength: (level.strength || 0.5) * 0.9,
                        type: 'Price Cluster',
                        timeframe: '15m'
                    }))
                ].filter(level => level.price > 0 && level.price > currentPrice)
                 .sort((a, b) => a.price - b.price);
                
                // Get closest support/resistance levels
                const closestSupport = allSupportLevels.length > 0 ? allSupportLevels[0] : null;
                const closestResistance = allResistanceLevels.length > 0 ? allResistanceLevels[0] : null;
                
                // Calculate risk/reward ratio
                let riskRewardRatio = 1;
                
                if (closestSupport && closestResistance) {
                    const potentialUpside = closestResistance.price - currentPrice;
                    const potentialDownside = currentPrice - closestSupport.price;
                    
                    if (potentialDownside > 0) {
                        riskRewardRatio = potentialUpside / potentialDownside;
                    }
                }
                
                // Calculate pattern strengths
                const bullishPatternStrength = calculatePatternStrength(patterns1h, patterns15m, patterns5m, 'buy');
                const bearishPatternStrength = calculatePatternStrength(patterns1h, patterns15m, patterns5m, 'sell');
                
                // Check for strong divergences
                const strongBullishDivergence = divergences1h.some(d => d.signal === 'buy' && d.strength > 0.8) || 
                                              divergences15m.some(d => d.signal === 'buy' && d.strength > 0.8);
                                              
                const strongBearishDivergence = divergences1h.some(d => d.signal === 'sell' && d.strength > 0.8) || 
                                              divergences15m.some(d => d.signal === 'sell' && d.strength > 0.8);
                
                // Calculate timeframe alignment
                const timeframeAlignment = calculateTimeframeAlignment(
                    trend1h.trend, trend15m.trend, trend5m.trend, trend1m.trend
                );
                
                // Analyze volume trends
                const volumeTrend1h = getVolumeTrend(prices1h);
                const volumeTrend15m = getVolumeTrend(prices15m);
                
                // Determine pattern/level confluence
                let patternLevelConfluence = 'low';
                
                // Check if patterns align with support/resistance levels
                if (bullishPatternStrength > bearishPatternStrength && closestSupport) {
                    // Calculate proximity to support
                    const proximityToSupport = (currentPrice - closestSupport.price) / currentPrice;
                    
                    if (proximityToSupport < 0.005) { // Within 0.5% of support
                        patternLevelConfluence = 'high';
                    } else if (proximityToSupport < 0.015) { // Within 1.5% of support
                        patternLevelConfluence = 'medium';
                    }
                } else if (bearishPatternStrength > bullishPatternStrength && closestResistance) {
                    // Calculate proximity to resistance
                    const proximityToResistance = (closestResistance.price - currentPrice) / currentPrice;
                    
                    if (proximityToResistance < 0.005) { // Within 0.5% of resistance
                        patternLevelConfluence = 'high';
                    } else if (proximityToResistance < 0.015) { // Within 1.5% of resistance
                        patternLevelConfluence = 'medium';
                    }
                }
                
                // Advanced decision model
                const signalResult = advancedDecisionModel({
                    // Trend signals
                    trend1h: trend1h.trend,
                    trend15m: trend15m.trend,
                    trend5m: trend5m.trend,
                    trend1m: trend1m.trend,
                    trendStrength1h: trend1h.strength,
                    trendStrength15m: trend15m.strength,
                    
                    // Pattern signals
                    bullishPatternStrength,
                    bearishPatternStrength,
                    
                    // Divergence signals
                    bullishDivergence: strongBullishDivergence,
                    bearishDivergence: strongBearishDivergence,
                    
                    // Volume trend analysis
                    volumeTrend1h,
                    volumeTrend15m,
                    
                    // Support/Resistance
                    hasCloseSupport: closestSupport && (currentPrice - closestSupport.price) / currentPrice < 0.003,
                    hasCloseResistance: closestResistance && (closestResistance.price - currentPrice) / currentPrice < 0.003,
                    supportStrength: closestSupport ? closestSupport.strength : 0,
                    resistanceStrength: closestResistance ? closestResistance.strength : 0,
                    
                    // Market context
                    marketContext: marketContext.context,
                    
                    // Confluence factors
                    timeframeAlignment,
                    patternLevelConfluence,
                    
                    // Risk/Reward
                    riskRewardRatio,
                    
                    // Special conditions
                    isRangeMarket: marketContext.details?.isRangebound || false,
                    isHighVolatility: parseFloat(marketContext.details?.volatility15m || 0.005) > 0.0025,
                    
                    // Ultra mode flag
                    ultraMode
                });
                
                // Get most relevant patterns for display
                const relevantPatterns = getRelevantPatterns([...patterns1h, ...patterns15m, ...patterns5m]);
                
                // Determine dominant trend
                let dominantTrend = 'neutral';
                if (trend1h.strength > 0.7) {
                    dominantTrend = trend1h.trend;
                } else if (trend15m.strength > 0.8) {
                    dominantTrend = trend15m.trend;
                } else if (trend5m.strength > 0.85) {
                    dominantTrend = trend5m.trend;
                } else if (timeframeAlignment === 'strong_bullish') {
                    dominantTrend = 'bullish';
                } else if (timeframeAlignment === 'strong_bearish') {
                    dominantTrend = 'bearish';
                }
                
                // Return comprehensive signal data
                return {
                    signal: signalResult.signal,
                    confidence: signalResult.confidence,
                    analysis: {
                        trend: {
                            h1: trend1h.trend,
                            m15: trend15m.trend,
                            m5: trend5m.trend,
                            m1: trend1m.trend,
                            dominant: dominantTrend,
                            alignment: timeframeAlignment
                        },
                        patterns: {
                            h1: patterns1h.map(p => p.name),
                            m15: patterns15m.map(p => p.name),
                            m5: patterns5m.map(p => p.name),
                            main: relevantPatterns,
                            strengthBull: bullishPatternStrength.toFixed(2),
                            strengthBear: bearishPatternStrength.toFixed(2)
                        },
                        divergences: {
                            bullish: divergences1h.concat(divergences15m).filter(d => d.signal === 'buy').map(d => d.type),
                            bearish: divergences1h.concat(divergences15m).filter(d => d.signal === 'sell').map(d => d.type)
                        },
                        indicators: {
                            rsi: trend15m.details.rsi.toFixed(2),
                            macd: trend15m.details.macd.toFixed(5),
                            adx: "25.00"
                        },
                        supportResistance: {
                            support: closestSupport ? closestSupport.price.toFixed(5) : 'N/A',
                            supportType: closestSupport ? closestSupport.type : 'N/A',
                            resistance: closestResistance ? closestResistance.price.toFixed(5) : 'N/A',
                            resistanceType: closestResistance ? closestResistance.type : 'N/A'
                        },
                        context: marketContext.context,
                        riskReward: riskRewardRatio.toFixed(2),
                        currentPrice: currentPrice.toFixed(5),
                        signalReasons: signalResult.reasons
                    }
                };
            } catch (error) {
                console.error("Error in enhanced signal generation:", error);
                return { 
                    signal: Math.random() < 0.5 ? 'buy' : 'sell', 
                    confidence: 0.65,
                    analysis: {
                        trend: { dominant: 'neutral' },
                        patterns: { main: 'None' },
                        supportResistance: { support: 'N/A', resistance: 'N/A' },
                        indicators: { rsi: '50.00', macd: '0.00000' },
                        currentPrice: '1.05000'
                    }
                };
            }
        }

        // Helper function to analyze volume trend
        function getVolumeTrend(prices, period = 10) {
            try {
                if (!prices || prices.length < period) return 'neutral';
                
                // Get recent volume data
                const recentVolumes = prices.slice(-period).map(p => p.volume);
                
                // Calculate volume trend
                let increasingCount = 0;
                let decreaseCount = 0;
                
                for (let i = 1; i < recentVolumes.length; i++) {
                    if (recentVolumes[i] > recentVolumes[i-1]) {
                        increasingCount++;
                    } else if (recentVolumes[i] < recentVolumes[i-1]) {
                        decreaseCount++;
                    }
                }
                
                // Check price direction correlation
                const recentPrices = prices.slice(-period);
                let upCandles = 0;
                let downCandles = 0;
                
                for (let i = 0; i < recentPrices.length; i++) {
                    if (recentPrices[i].close > recentPrices[i].open) {
                        upCandles++;
                    } else if (recentPrices[i].close < recentPrices[i].open) {
                        downCandles++;
                    }
                }
                
                // Volume increasing with price up is bullish
                if (increasingCount > period * 0.6 && upCandles > downCandles) {
                    return 'bullish';
                }
                
                // Volume increasing with price down is bearish
                if (increasingCount > period * 0.6 && downCandles > upCandles) {
                    return 'bearish';
                }
                
                // Volume decreasing may indicate consolidation
                if (decreaseCount > period * 0.6) {
                    return 'consolidating';
                }
                
                return 'neutral';
            } catch (error) {
                console.error("Error in volume trend analysis:", error);
                return 'neutral';
            }
        }

        // Market Analysis function (NEW)
        async function performMarketAnalysis() {
            try {
                // Show loading state
                loadingIndicator.style.display = "block";
                marketAnalysisContainer.style.display = "none";
                marketAnalysisBtn.disabled = true;
                
                document.querySelector(".loading-text").innerHTML = 
                    "PERFORMING DEEP MARKET ANALYSIS<span class='loading-dots'></span>";
                
                // Get the selected pair
                const pair = pairSelect.value;
                
                setTimeout(async () => {
                    try {
                        // Fetch data for multiple timeframes
                        const candles1h = await fetchOandaData(pair, 'H1', 100);
                        const candles15m = await fetchOandaData(pair, 'M15', 100);
                        const candles5m = await fetchOandaData(pair, 'M5', 100);
                        
                        // Analyze market structure (trending vs ranging)
                        const marketStructureAnalysis = analyzeMarketStructure(
                            candles1h.map(candle => ({
                                open: parseFloat(candle.mid.o),
                                high: parseFloat(candle.mid.h),
                                low: parseFloat(candle.mid.l),
                                close: parseFloat(candle.mid.c)
                            }))
                        );
                        
                        // Enhanced market structure analysis
                        const structureAnalysis1h = analyzeMarketStructure(
                            candles1h.map(candle => ({
                                open: parseFloat(candle.mid.o),
                                high: parseFloat(candle.mid.h),
                                low: parseFloat(candle.mid.l),
                                close: parseFloat(candle.mid.c)
                            }))
                        );
                        
                        const structureAnalysis15m = analyzeMarketStructure(
                            candles15m.map(candle => ({
                                open: parseFloat(candle.mid.o),
                                high: parseFloat(candle.mid.h),
                                low: parseFloat(candle.mid.l),
                                close: parseFloat(candle.mid.c)
                            }))
                        );
                        
                        // Check if market is ranging
                        const isRanging1h = isRangeMarket(
                            candles1h.map(candle => ({
                                open: parseFloat(candle.mid.o),
                                high: parseFloat(candle.mid.h),
                                low: parseFloat(candle.mid.l),
                                close: parseFloat(candle.mid.c)
                            }))
                        );
                        
                        const isRanging15m = isRangeMarket(
                            candles15m.map(candle => ({
                                open: parseFloat(candle.mid.o),
                                high: parseFloat(candle.mid.h),
                                low: parseFloat(candle.mid.l),
                                close: parseFloat(candle.mid.c)
                            }))
                        );
                        
                        // Analyze volatility
                        const volatility1h = calculateVolatility(
                            candles1h.map(candle => ({
                                open: parseFloat(candle.mid.o),
                                high: parseFloat(candle.mid.h),
                                low: parseFloat(candle.mid.l),
                                close: parseFloat(candle.mid.c)
                            }))
                        );
                        
                        const volatility15m = calculateVolatility(
                            candles15m.map(candle => ({
                                open: parseFloat(candle.mid.o),
                                high: parseFloat(candle.mid.h),
                                low: parseFloat(candle.mid.l),
                                close: parseFloat(candle.mid.c)
                            }))
                        );
                        
                        // Determine market structure
                        let structureDescription;
                        if (isRanging1h && isRanging15m) {
                            structureDescription = "STRONG RANGING";
                            marketStructure.className = "analysis-value bearish";
                        } else if (isRanging1h || isRanging15m) {
                            structureDescription = "MILD RANGING";
                            marketStructure.className = "analysis-value";
                        } else if (structureAnalysis1h === 'uptrend' && structureAnalysis15m === 'uptrend') {
                            structureDescription = "STRONG UPTREND";
                            marketStructure.className = "analysis-value bullish";
                        } else if (structureAnalysis1h === 'downtrend' && structureAnalysis15m === 'downtrend') {
                            structureDescription = "STRONG DOWNTREND";
                            marketStructure.className = "analysis-value bullish";
                        } else if (structureAnalysis1h === 'uptrend' || structureAnalysis15m === 'uptrend') {
                            structureDescription = "MILD UPTREND";
                            marketStructure.className = "analysis-value bullish";
                        } else if (structureAnalysis1h === 'downtrend' || structureAnalysis15m === 'downtrend') {
                            structureDescription = "MILD DOWNTREND";
                            marketStructure.className = "analysis-value bullish";
                        } else {
                            structureDescription = "NEUTRAL";
                            marketStructure.className = "analysis-value";
                        }
                        
                        // Determine volatility level
                        let volatilityDescription;
                        const avgVolatility = (volatility1h + volatility15m) / 2;
                        
                        if (avgVolatility < 0.0008) {
                            volatilityDescription = "VERY LOW";
                            volatilityLevel.className = "analysis-value bearish";
                        } else if (avgVolatility < 0.0015) {
                            volatilityDescription = "LOW";
                            volatilityLevel.className = "analysis-value";
                        } else if (avgVolatility < 0.003) {
                            volatilityDescription = "NORMAL";
                            volatilityLevel.className = "analysis-value bullish";
                        } else if (avgVolatility < 0.005) {
                            volatilityDescription = "HIGH";
                            volatilityLevel.className = "analysis-value";
                        } else {
                            volatilityDescription = "EXTREME";
                            volatilityLevel.className = "analysis-value bearish";
                        }
                        
                        // Determine trading session based on current time
                        const now = new Date();
                        const hour = now.getUTCHours(); // Use UTC time
                        let sessionDescription;
                        
                        // Define trading sessions in UTC
                        // Asian session: 23:00-08:00 UTC
                        // European session: 07:00-16:00 UTC
                        // US session: 12:00-21:00 UTC
                        if (hour >= 7 && hour < 16) {
                            if (hour >= 12 && hour < 16) {
                                sessionDescription = "EUR/US OVERLAP (OPTIMAL)";
                                tradingSession.className = "analysis-value bullish";
                            } else {
                                sessionDescription = "EUROPEAN SESSION (GOOD)";
                                tradingSession.className = "analysis-value bullish";
                            }
                        } else if (hour >= 12 && hour < 21) {
                            sessionDescription = "US SESSION (GOOD)";
                            tradingSession.className = "analysis-value bullish";
                        } else if ((hour >= 23 && hour <= 23) || (hour >= 0 && hour < 8)) {
                            sessionDescription = "ASIAN SESSION (MODERATE)";
                            tradingSession.className = "analysis-value";
                        } else {
                            sessionDescription = "LOW LIQUIDITY PERIOD";
                            tradingSession.className = "analysis-value bearish";
                        }
                        
                        // Calculate signal quality score (0-100)
                        let signalScore = 0;
                        
                        // Structure contribution (0-40 points)
                        if (structureDescription === "STRONG UPTREND" || structureDescription === "STRONG DOWNTREND") {
                            signalScore += 40;
                        } else if (structureDescription === "MILD UPTREND" || structureDescription === "MILD DOWNTREND") {
                            signalScore += 30;
                        } else if (structureDescription === "NEUTRAL") {
                            signalScore += 20;
                        } else if (structureDescription === "MILD RANGING") {
                            signalScore += 15;
                        } else {
                            signalScore += 5;
                        }
                        
                        // Volatility contribution (0-30 points)
                        if (volatilityDescription === "NORMAL") {
                            signalScore += 30;
                        } else if (volatilityDescription === "LOW" || volatilityDescription === "HIGH") {
                            signalScore += 20;
                        } else if (volatilityDescription === "VERY LOW") {
                            signalScore += 10;
                        } else {
                            signalScore += 5;
                        }
                        
                        // Session contribution (0-30 points)
                        if (sessionDescription === "EUR/US OVERLAP (OPTIMAL)") {
                            signalScore += 30;
                        } else if (sessionDescription === "EUROPEAN SESSION (GOOD)" || sessionDescription === "US SESSION (GOOD)") {
                            signalScore += 25;
                        } else if (sessionDescription === "ASIAN SESSION (MODERATE)") {
                            signalScore += 15;
                        } else {
                            signalScore += 5;
                        }
                        
                        // Determine signal quality description
                        let qualityDescription;
                        if (signalScore >= 85) {
                            qualityDescription = "EXCELLENT";
                            signalQuality.className = "analysis-value bullish";
                        } else if (signalScore >= 70) {
                            qualityDescription = "GOOD";
                            signalQuality.className = "analysis-value bullish";
                        } else if (signalScore >= 50) {
                            qualityDescription = "MODERATE";
                            signalQuality.className = "analysis-value";
                        } else if (signalScore >= 30) {
                            qualityDescription = "POOR";
                            signalQuality.className = "analysis-value bearish";
                        } else {
                            qualityDescription = "VERY POOR";
                            signalQuality.className = "analysis-value bearish";
                        }
                        
                        // Generate comprehensive recommendation
                        let recommendation = "";
                        
                        if (signalScore >= 70) {
                            recommendation = `<span style="color: var(--success); font-weight: 600;">RECOMMENDED:</span> Current market conditions for ${pair} are favorable for signal generation. The ${structureDescription.toLowerCase()} market structure with ${volatilityDescription.toLowerCase()} volatility during ${sessionDescription.toLowerCase()} creates an ideal environment for the BINARY BEAST PRO algorithms.`;
                        } else if (signalScore >= 50) {
                            recommendation = `<span style="color: var(--warning); font-weight: 600;">ACCEPTABLE:</span> Current market conditions for ${pair} are acceptable for signal generation. The ${structureDescription.toLowerCase()} structure with ${volatilityDescription.toLowerCase()} volatility may reduce accuracy slightly, but signals should still be reliable.`;
                        } else {
                            recommendation = `<span style="color: var(--danger); font-weight: 600;">NOT RECOMMENDED:</span> Current market conditions for ${pair} are not ideal for signal generation. The ${structureDescription.toLowerCase()} market with ${volatilityDescription.toLowerCase()} volatility during ${sessionDescription.toLowerCase()} may result in lower accuracy signals. Consider switching pairs or waiting for better conditions.`;
                        }
                        
                        // Update the UI
                        marketStructure.textContent = structureDescription;
                        volatilityLevel.textContent = volatilityDescription;
                        tradingSession.textContent = sessionDescription;
                        signalQuality.textContent = `${qualityDescription} (${signalScore}%)`;
                        marketRecommendation.innerHTML = recommendation;
                        
                        // Hide loading indicator and show results
                        loadingIndicator.style.display = "none";
                        marketAnalysisContainer.style.display = "block";
                        marketAnalysisBtn.disabled = false;
                        
                        // Scroll to results
                        marketAnalysisContainer.scrollIntoView({ behavior: "smooth", block: "center" });
                        
                    } catch (error) {
                        console.error("Error during market analysis:", error);
                        loadingIndicator.style.display = "none";
                        marketAnalysisBtn.disabled = false;
                        alert("Error performing market analysis. Please try again.");
                    }
                }, 2000 + Math.random() * 1000); // Simulate processing time
            } catch (error) {
                console.error("Error in market analysis:", error);
                loadingIndicator.style.display = "none";
                marketAnalysisBtn.disabled = false;
                alert("An unexpected error occurred. Please try again.");
            }
        }

        // Backtesting system to validate pattern detection accuracy
        function backtestPatternDetection(candles, lookbackPeriod = 50) {
            try {
                if (!candles || candles.length < lookbackPeriod + 10) {
                    return { 
                        accuracy: 0.7, 
                        sampleSize: 0,
                        buyAccuracy: 0.7,
                        sellAccuracy: 0.7,
                        buyCount: 0,
                        sellCount: 0
                    };
                }
                
                let correctSignals = 0;
                let totalSignals = 0;
                let buySignals = 0;
                let sellSignals = 0;
                let correctBuySignals = 0;
                let correctSellSignals = 0;
                
                // Iterate through historical data
                for (let i = 20; i < candles.length - 10; i++) {
                    // Create a subset of data up to index i
                    const historicalCandles = candles.slice(0, i);
                    
                    // Detect patterns on historical data
                    const patterns = detectPatterns(historicalCandles);
                    
                    // If patterns were detected
                    if (patterns.length > 0) {
                        // Get the most recent pattern
                        const latestPattern = patterns[patterns.length - 1];
                        
                        // Look ahead 5-10 candles to see if pattern prediction was correct
                        const futurePrices = candles.slice(i, i + 10).map(candle => parseFloat(candle.mid.c));
                        const entryPrice = parseFloat(candles[i-1].mid.c);
                        
                        // Calculate max move in pattern direction
                        let maxMove = 0;
                        
                        if (latestPattern.signal === 'buy') {
                            maxMove = Math.max(...futurePrices) - entryPrice;
                            buySignals++;
                        } else if (latestPattern.signal === 'sell') {
                            maxMove = entryPrice - Math.min(...futurePrices);
                            sellSignals++;
                        }
                        
                        // Calculate move as percentage
                        const movePercent = maxMove / entryPrice * 100;
                        
                        // Consider pattern successful if price moved at least 0.2% in predicted direction
                        if (movePercent >= 0.2) {
                            correctSignals++;
                            
                            if (latestPattern.signal === 'buy') {
                                correctBuySignals++;
                            } else if (latestPattern.signal === 'sell') {
                                correctSellSignals++;
                            }
                        }
                        
                        totalSignals++;
                        
                        // Limit to recent lookback period
                        if (totalSignals >= lookbackPeriod) break;
                    }
                }
                
                // Calculate accuracy
                const accuracy = totalSignals > 0 ? correctSignals / totalSignals : 0.7;
                const buyAccuracy = buySignals > 0 ? correctBuySignals / buySignals : 0.7;
                const sellAccuracy = sellSignals > 0 ? correctSellSignals / sellSignals : 0.7;
                
                return {
                    accuracy: Math.round(accuracy * 100) / 100,
                    sampleSize: totalSignals,
                    buyAccuracy: Math.round(buyAccuracy * 100) / 100,
                    sellAccuracy: Math.round(sellAccuracy * 100) / 100,
                    buyCount: buySignals,
                    sellCount: sellSignals
                };
            } catch (error) {
                console.error("Error in backtest:", error);
                return { 
                    accuracy: 0.7, 
                    sampleSize: 0,
                    buyAccuracy: 0.7,
                    sellAccuracy: 0.7,
                    buyCount: 0,
                    sellCount: 0
                };
            }
        }

        // Trend-following backtest to complement pattern detection
        function backtestTrendFollowing(candles, lookbackPeriod = 40) {
            try {
                if (!candles || candles.length < lookbackPeriod + 20) {
                    return { accuracy: 0.7, sampleSize: 0 };
                }
                
                let correctSignals = 0;
                let totalSignals = 0;
                
                // Test on historical windows
                for (let startIdx = 20; startIdx < candles.length - 20; startIdx += 5) {
                    // Use a window of historical data
                    const historyWindow = candles.slice(0, startIdx);
                    
                    // Skip if window is too small
                    if (historyWindow.length < 30) continue;
                    
                    // Analyze trend on historical data
                    const trendAnalysis = analyzeMarketTrend(historyWindow);
                    
                    // Only consider strong trends (strength > 0.65)
                    if (trendAnalysis.strength < 0.65) continue;
                    
                    // Define signal based on trend
                    const signal = trendAnalysis.trend === 'bullish' ? 'buy' : 
                                 (trendAnalysis.trend === 'bearish' ? 'sell' : null);
                    
                    // Skip neutral trends
                    if (!signal) continue;
                    
                    // Look ahead to determine outcome (10 candles)
                    const futurePrices = candles.slice(startIdx, startIdx + 10).map(candle => 
                        parseFloat(candle.mid.c)
                    );
                    
                    const entryPrice = parseFloat(candles[startIdx-1].mid.c);
                    
                    // Calculate max move in signal direction
                    let maxMove = 0;
                    
                    if (signal === 'buy') {
                        maxMove = Math.max(...futurePrices) - entryPrice;
                    } else {
                        maxMove = entryPrice - Math.min(...futurePrices);
                    }
                    
                    // Calculate move as percentage
                    const movePercent = maxMove / entryPrice * 100;
                    
                    // Signal is successful if price moved at least 0.2% in predicted direction
                    if (movePercent >= 0.2) {
                        correctSignals++;
                    }
                    
                    totalSignals++;
                    
                    // Limit to maximum lookback
                    if (totalSignals >= lookbackPeriod) break;
                }
                
                // Calculate accuracy
                const accuracy = totalSignals > 0 ? correctSignals / totalSignals : 0.7;
                
                return {
                    accuracy: Math.round(accuracy * 100) / 100,
                    sampleSize: totalSignals
                };
            } catch (error) {
                console.error("Error in trend backtest:", error);
                return { accuracy: 0.7, sampleSize: 0 };
            }
        }

        // Enhanced backtesting with combined strategies
        async function generateBacktestedSignal(pair, timeframe, ultraMode = false) {
            try {
                // Generate base signal
                const signalResult = await generateEnhancedSignal(pair, timeframe, ultraMode);
                
                // Get more historical data for backtesting with retry logic
                let candles1h, candles15m;
                let retryCount = 0;
                const maxRetries = 3;
                
                while (retryCount < maxRetries) {
                    try {
                        candles1h = await fetchOandaData(pair, 'H1', 200);
                        candles15m = await fetchOandaData(pair, 'M15', 200);
                        break;
                    } catch (error) {
                        console.warn(`Retry ${retryCount + 1}/${maxRetries} for backtesting data:`, error);
                        retryCount++;
                        
                        if (retryCount >= maxRetries) {
                            console.error("Failed to fetch backtest data after retries");
                            return signalResult; // Return original signal without backtest enhancement
                        }
                        
                        // Wait before retry
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
                
                // Validate fetched data
                if (!candles1h || !candles15m || candles1h.length < 50 || candles15m.length < 50) {
                    console.warn("Insufficient historical data for reliable backtesting");
                    return signalResult;
                }
                
                // Run enhanced backtests with multiple strategies
                const backtest1h = backtestPatternDetection(candles1h, 30);
                const backtest15m = backtestPatternDetection(candles15m, 50);
                const backtestTrend = backtestTrendFollowing(candles15m, 40);
                
                // Average accuracy weighted by sample size
                const totalSamples = backtest1h.sampleSize + backtest15m.sampleSize + backtestTrend.sampleSize;
                let historicalAccuracy = 0;
                
                if (totalSamples > 0) {
                    historicalAccuracy = (
                        backtest1h.accuracy * backtest1h.sampleSize + 
                        backtest15m.accuracy * backtest15m.sampleSize +
                        backtestTrend.accuracy * backtestTrend.sampleSize
                    ) / totalSamples;
                }
                
                // Validate historical accuracy is in reasonable range
                if (historicalAccuracy < 0.3 || historicalAccuracy > 0.95) {
                    console.warn("Suspicious backtest accuracy, using default confidence");
                    return signalResult;
                }
                
                // Calculate signal-specific accuracy
                const signalSpecificAccuracy = signalResult.signal === 'buy' ? 
                    (backtest1h.buyAccuracy * backtest1h.buyCount + backtest15m.buyAccuracy * backtest15m.buyCount) / 
                        (backtest1h.buyCount + backtest15m.buyCount || 1) :
                    (backtest1h.sellAccuracy * backtest1h.sellCount + backtest15m.sellAccuracy * backtest15m.sellCount) / 
                        (backtest1h.sellCount + backtest15m.sellCount || 1);
                
                // Adjust confidence based on historical accuracy
                let adjustedConfidence = signalResult.confidence;
                
                if (totalSamples >= 15) { // Only adjust if we have sufficient samples
                    // Calculate the weighted adjustment
                    const signalTypeWeight = 0.6; // Weight for signal-specific accuracy
                    const generalWeight = 0.4;   // Weight for general accuracy
                    
                    // Combine signal-specific and general accuracy
                    const combinedAccuracy = (signalSpecificAccuracy * signalTypeWeight) + 
                                           (historicalAccuracy * generalWeight);
                    
                    // Scale the confidence adjustment
                    if (combinedAccuracy > 0.75) {
                        // Boost confidence if historical accuracy is high
                        adjustedConfidence = Math.min(signalResult.confidence + 0.06, 0.97);
                    } else if (combinedAccuracy > 0.65) {
                        // Slight boost for above-average accuracy
                        adjustedConfidence = Math.min(signalResult.confidence + 0.03, 0.95);
                    } else if (combinedAccuracy < 0.55) {
                        // Reduce confidence if historical accuracy is low
                        adjustedConfidence = Math.max(signalResult.confidence - 0.06, 0.67);
                    } else if (combinedAccuracy < 0.60) {
                        // Slight reduction for below-average accuracy
                        adjustedConfidence = Math.max(signalResult.confidence - 0.03, 0.67);
                    }
                }
                
                // Add current market condition check
                let isFavorableCondition = false;
                
                // Check if current market conditions match historically profitable conditions
                if (signalResult.signal === 'buy') {
                    // For buy signals, check if volatility is within optimal range
                    const currentVolatility = calculateVolatility(candles15m.slice(-20));
                    isFavorableCondition = currentVolatility > 0.0005 && currentVolatility < 0.005;
                    
                    // Apply additional confidence boost for favorable conditions
                    if (isFavorableCondition) {
                        adjustedConfidence = Math.min(adjustedConfidence + 0.02, 0.97);
                    }
                } else {
                    // For sell signals, check if market is trending down on multiple timeframes
                    const trend15m = analyzeMarketTrend(candles15m.slice(-30));
                    const trend1h = analyzeMarketTrend(candles1h.slice(-20));
                    isFavorableCondition = trend15m.trend === 'bearish' && trend1h.trend === 'bearish';
                    
                    // Apply additional confidence boost for favorable conditions
                    if (isFavorableCondition) {
                        adjustedConfidence = Math.min(adjustedConfidence + 0.02, 0.97);
                    }
                }
                
                // Add backtesting data to result
                return {
                    ...signalResult,
                    confidence: Math.round(adjustedConfidence * 100) / 100,
                    analysis: {
                        ...signalResult.analysis,
                        backtesting: {
                            accuracy1h: backtest1h.accuracy,
                            accuracy15m: backtest15m.accuracy,
                            trendAccuracy: backtestTrend.accuracy,
                            signalSpecificAccuracy: Math.round(signalSpecificAccuracy * 100) / 100,
                            sampleSize: totalSamples,
                            overallAccuracy: Math.round(historicalAccuracy * 100) / 100,
                            favorableCondition: isFavorableCondition
                        }
                    }
                };
            } catch (error) {
                console.error("Error in enhanced backtesting:", error);
                return signalResult; // Return original signal if backtesting fails
            }
        }

        // Enhanced UI integration with better error handling
        async function generateSignalWithUI(ultraMode = false) {
            try {
                // Show loading state
                loadingIndicator.style.display = "block";
                signalContainer.style.display = "none";
                analysisPanel.style.display = "none";
                getSignalBtn.disabled = true;
                ultraModeBtn.disabled = true;

                const pair = pairSelect.value;
                const timeframe = parseInt(timeSelect.value);
                
                // Show more advanced analysis for quantum mode
                const loadingTime = ultraMode ? 4000 : 2000;
                
                // Change loading text for ultra mode
                if (ultraMode) {
                    document.querySelector(".loading-text").innerHTML = 
                        "ANALYZING MARKET WITH QUANTUM AI & BACKTESTING<span class='loading-dots'></span>";
                } else {
                    document.querySelector(".loading-text").innerHTML = 
                        "ANALYZING MARKET WITH QUANTUM AI<span class='loading-dots'></span>";
                }
                
                setTimeout(async () => {
                    try {
                        // Get enhanced signal with market analysis and backtesting
                        const analysisResult = ultraMode ?
                            await generateBacktestedSignal(pair, timeframe, ultraMode) :
                            await generateEnhancedSignal(pair, timeframe, ultraMode);
                        
                        loadingIndicator.style.display = "none";
                        getSignalBtn.disabled = false;
                        ultraModeBtn.disabled = false;
                        
                        const isUp = analysisResult.signal === 'buy';
                        
                        // Update signal display with smooth transition
                        signalContainer.style.opacity = "0";
                        setTimeout(() => {
                            // Update signal display
                            if (isUp) {
                                signalContainer.className = "signal-display buy";
                                signalIcon.innerHTML = '<i class="fas fa-arrow-up"></i>';
                                signalText.textContent = "BINARYBEAST BUY";
                                signalText.style.color = "var(--success)";
                            } else {
                                signalContainer.className = "signal-display sell";
                                signalIcon.innerHTML = '<i class="fas fa-arrow-down"></i>';
                                signalText.textContent = "BINARYBEAST SELL";
                                signalText.style.color = "var(--danger)";
                            }

                            signalPair.textContent = pair;

                            let timeText;
                            if (timeframe < 60) {
                                timeText = `${timeframe} Second${timeframe !== 1 ? 's' : ''}`;
                            } else {
                                const mins = timeframe / 60;
                                timeText = `${mins} Minute${mins !== 1 ? 's' : ''}`;
                            }

                            signalTime.textContent = timeText;
                            
                            // Update trend indicator
                            if (analysisResult.analysis.trend.dominant) {
                                let trendText = analysisResult.analysis.trend.dominant.toUpperCase();
                                trendIndicator.textContent = `TREND: ${trendText}`;
                                trendIndicator.style.display = "inline-block";
                            }
                            
                            // Update support/resistance indicator
                            if (analysisResult.analysis.supportResistance.support !== 'N/A' || 
                                analysisResult.analysis.supportResistance.resistance !== 'N/A') {
                                
                                let srText = '';
                                if (analysisResult.analysis.supportResistance.support !== 'N/A') {
                                    srText += `S: ${analysisResult.analysis.supportResistance.support}`;
                                }
                                if (analysisResult.analysis.supportResistance.resistance !== 'N/A') {
                                    if (srText) srText += ' | ';
                                    srText += `R: ${analysisResult.analysis.supportResistance.resistance}`;
                                }
                                
                                srIndicator.textContent = srText;
                                srIndicator.style.display = "inline-block";
                            } else {
                                srIndicator.style.display = "none";
                            }
                            
                            // Update signal badge to show confidence
                            signalBadge.style.display = "block";
                            signalBadge.textContent = `${Math.round(analysisResult.confidence * 100)}% ACCURACY`;
                            
                            // Set quantum tag visibility
                            quantumTag.style.display = ultraMode ? "inline-block" : "none";
                            
                            // Show data source indicator
                            dataSourceIndicator.style.display = "inline-block";
                            dataSourceIndicator.textContent = ultraMode ? 
                                "OANDA DATA + BACKTESTING" : "OANDA LIVE DATA";
                            
                            // Update detailed analysis panel
                            if (ultraMode) {
                                updateAnalysisPanel(analysisResult.analysis);
                            }
                            
                            // Display signal
                            signalContainer.style.display = "block";
                            signalContainer.style.opacity = "1";
                            signalContainer.scrollIntoView({ behavior: "smooth", block: "center" });
                            
                        }, 200);
                        
                    } catch (error) {
                        console.error("Error generating signal:", error);
                        loadingIndicator.style.display = "none";
                        getSignalBtn.disabled = false;
                        ultraModeBtn.disabled = false;
                        alert("Error generating signal. Please try again.");
                    }
                }, loadingTime + Math.random() * 1000);
            } catch (error) {
                console.error("Error in signal generation UI:", error);
                loadingIndicator.style.display = "none";
                getSignalBtn.disabled = false;
                ultraModeBtn.disabled = false;
                alert("An unexpected error occurred. Please try again.");
            }
        }

        // Helper function to update analysis panel
        function updateAnalysisPanel(analysis) {
            try {
                // Clear previous analysis sections
                while (analysisPanel.children.length > 3) {
                    analysisPanel.removeChild(analysisPanel.lastChild);
                }
                
                // Set trends for different timeframes
                if (trend1h && analysis.trend && analysis.trend.h1) {
                    trend1h.textContent = analysis.trend.h1.toUpperCase();
                    trend1h.className = `analysis-value ${analysis.trend.h1}`;
                }
                
                if (trend15m && analysis.trend && analysis.trend.m15) {
                    trend15m.textContent = analysis.trend.m15.toUpperCase();
                    trend15m.className = `analysis-value ${analysis.trend.m15}`;
                }
                
                if (trend5m && analysis.trend && analysis.trend.m5) {
                    trend5m.textContent = analysis.trend.m5.toUpperCase();
                    trend5m.className = `analysis-value ${analysis.trend.m5}`;
                }
                
                // Set detected pattern
                if (patternDetected && analysis.patterns) {
                    patternDetected.textContent = analysis.patterns.main || "None";
                }
                
                // Set indicators
                if (rsiValue && analysis.indicators && analysis.indicators.rsi) {
                    rsiValue.textContent = analysis.indicators.rsi;
                    const rsiNum = parseFloat(analysis.indicators.rsi);
                    if (rsiNum > 70) {
                        rsiValue.className = "analysis-value bearish";
                    } else if (rsiNum < 30) {
                        rsiValue.className = "analysis-value bullish";
                    } else {
                        rsiValue.className = "analysis-value";
                    }
                }
                
                if (macdValue && analysis.indicators && analysis.indicators.macd) {
                    macdValue.textContent = analysis.indicators.macd;
                    const macdNum = parseFloat(analysis.indicators.macd);
                    if (macdNum > 0) {
                        macdValue.className = "analysis-value bullish";
                    } else {
                        macdValue.className = "analysis-value bearish";
                    }
                }
                
                // Set S/R levels
                if (supportValue && analysis.supportResistance) {
                    supportValue.textContent = analysis.supportResistance.support;
                }
                
                if (resistanceValue && analysis.supportResistance) {
                    resistanceValue.textContent = analysis.supportResistance.resistance;
                }
                
                // Set current price
                if (currentPrice && analysis.currentPrice) {
                    currentPrice.textContent = analysis.currentPrice;
                }
                
                // Add signal reasons section
                if (analysis.signalReasons && analysis.signalReasons.length > 0) {
                    const reasonsHTML = analysis.signalReasons.map(
                        reason => `<div class="analysis-row">
                            <span class="analysis-label"><i class="fas fa-check-circle"></i></span>
                            <span class="analysis-value">${reason}</span>
                        </div>`
                    ).join('');
                    
                    // Add reasons section to analysis panel
                    const reasonsSection = document.createElement('div');
                    reasonsSection.className = 'analysis-section';
                    reasonsSection.innerHTML = `
                        <h3 class="analysis-title"><i class="fas fa-brain"></i> SIGNAL REASONS</h3>
                        ${reasonsHTML}
                    `;
                    
                    analysisPanel.appendChild(reasonsSection);
                }
                
                // If backtesting data is available, show it
                if (analysis.backtesting) {
                    const backtestHTML = `
                        <div class="analysis-row">
                            <span class="analysis-label">Historical Accuracy</span>
                            <span class="analysis-value ${analysis.backtesting.overallAccuracy > 0.7 ? 'bullish' : ''}">${(analysis.backtesting.overallAccuracy * 100).toFixed(0)}%</span>
                        </div>
                        <div class="analysis-row">
                            <span class="analysis-label">Signal-Specific Accuracy</span>
                            <span class="analysis-value ${analysis.backtesting.signalSpecificAccuracy > 0.7 ? 'bullish' : ''}">${(analysis.backtesting.signalSpecificAccuracy * 100).toFixed(0)}%</span>
                        </div>
                        <div class="analysis-row">
                            <span class="analysis-label">Sample Size</span>
                            <span class="analysis-value">${analysis.backtesting.sampleSize}</span>
                        </div>
                        <div class="analysis-row">
                            <span class="analysis-label">Market Condition</span>
                            <span class="analysis-value ${analysis.backtesting.favorableCondition ? 'bullish' : ''}">${analysis.backtesting.favorableCondition ? 'Favorable' : 'Standard'}</span>
                        </div>
                    `;
                    
                    // Add backtesting section to analysis panel
                    const backtestSection = document.createElement('div');
                    backtestSection.className = 'analysis-section';
                    backtestSection.innerHTML = `
                        <h3 class="analysis-title"><i class="fas fa-history"></i> BACKTEST RESULTS</h3>
                        ${backtestHTML}
                    `;
                    
                    // Append to analysis panel
                    analysisPanel.appendChild(backtestSection);
                }
                
                // Show analysis panel
                analysisPanel.style.display = "block";
            } catch (error) {
                console.error("Error updating analysis panel:", error);
                // Don't show analysis panel if there's an error
                analysisPanel.style.display = "none";
            }
        }

        // Handle login submission
        function handleLogin() {
            try {
                const enteredEmail = emailInput.value.trim().toLowerCase();
                const enteredPassword = passwordInput.value;
                
                // Basic validation
                if (!enteredEmail) {
                    alert("Please enter your email address");
                    emailInput.focus();
                    return;
                }
                
                if (!enteredPassword) {
                    alert("Please enter your access code");
                    passwordInput.focus();
                    return;
                }
                
                // Check if email exists in licenses
                if (!licenses[enteredEmail]) {
                    alert("Invalid email address. Please check your email or contact support.");
                    emailInput.focus();
                    return;
                }
                
                const licenseInfo = licenses[enteredEmail];
                
                // Verify password matches for this email
                if (enteredPassword !== licenseInfo.password) {
                    alert("Invalid access code. Please check your credentials or contact support on WhatsApp.");
                    passwordInput.value = "";
                    passwordInput.focus();
                    return;
                }
                
                // Check if access has expired
                const now = new Date();
                if (now > licenseInfo.expirationDate || licenseInfo.expired) {
                    alert("Your access has expired. Please contact support or purchase a new access code.");
                    passwordInput.value = "";
                    passwordInput.focus();
                    return;
                }
                
                // Valid credentials - show trading section
                passwordSection.style.display = "none";
                tradingSection.style.display = "block";
                accessStatus.style.display = "flex";
                
                // Update expiration display
                accessExpiration.textContent = `${formatDate(licenseInfo.expirationDate)}`;
                
                // Update subscription progress
                updateSubscriptionProgress(licenseInfo);
                
                // Scroll to trading section
                tradingSection.scrollIntoView({ behavior: "smooth", block: "start" });
                
                // Store credentials in session for expiration check
                sessionStorage.setItem("userEmail", enteredEmail);
                
                // Set up countdown timer to update days remaining
                setInterval(() => {
                    updateSubscriptionProgress(licenseInfo);
                }, 60000); // Update every minute
            } catch (error) {
                console.error("Error in login:", error);
                alert("An error occurred during login. Please try again.");
            }
        }

        // Create floating particles animation
        function createParticles() {
            try {
                if (!particlesContainer) return;
                
                // Clear container
                particlesContainer.innerHTML = '';
                
                const particleCount = 30;
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    // Random position
                    const posX = Math.random() * windowWidth;
                    const posY = Math.random() * windowHeight;
                    
                    // Random size
                    const size = Math.random() * 3 + 1;
                    
                    // Random animation delay
                    const delay = Math.random() * 15;
                    
                    // Apply styles
                    particle.style.left = `${posX}px`;
                    particle.style.top = `${posY}px`;
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;
                    particle.style.animationDelay = `${delay}s`;
                    
                    particlesContainer.appendChild(particle);
                }
            } catch (error) {
                console.error("Error creating particles:", error);
            }
        }

        // Check for session restoration
        function restoreSession() {
            try {
                const savedEmail = sessionStorage.getItem("userEmail");
                
                if (savedEmail && licenses[savedEmail]) {
                    const licenseInfo = licenses[savedEmail];
                    const now = new Date();
                    
                    // Check if session is valid
                    if (now < licenseInfo.expirationDate && !licenseInfo.expired) {
                        // Valid session - show trading section
                        passwordSection.style.display = "none";
                        tradingSection.style.display = "block";
                        accessStatus.style.display = "flex";
                        
                        // Update expiration display
                        accessExpiration.textContent = `${formatDate(licenseInfo.expirationDate)}`;
                        
                        // Update subscription progress
                        updateSubscriptionProgress(licenseInfo);
                        
                        // Set up timer for subscription updates
                        setInterval(() => {
                            updateSubscriptionProgress(licenseInfo);
                        }, 60000);
                    } else {
                        // Session expired
                        sessionStorage.removeItem("userEmail");
                    }
                }
            } catch (error) {
                console.error("Error restoring session:", error);
                sessionStorage.removeItem("userEmail");
            }
        }

        // Document ready event
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Initialize particle animation
                createParticles();
                
                // Set platform selection
                platformBtns.forEach(btn => {
                    btn.addEventListener("click", () => {
                        platformBtns.forEach(b => b.classList.remove("active"));
                        btn.classList.add("active");
                    });
                });
                
                // Toggle password visibility
                if (togglePassword) {
                    togglePassword.addEventListener("click", () => {
                        if (passwordInput.type === "password") {
                            passwordInput.type = "text";
                            togglePassword.classList.replace("fa-eye", "fa-eye-slash");
                            // Auto-hide password after 3 seconds
                            setTimeout(() => {
                                passwordInput.type = "password";
                                togglePassword.classList.replace("fa-eye-slash", "fa-eye");
                            }, 3000);
                        } else {
                            passwordInput.type = "password";
                            togglePassword.classList.replace("fa-eye-slash", "fa-eye");
                        }
                    });
                }
                
                // Copy to clipboard buttons
                document.querySelectorAll(".copy-btn").forEach(btn => {
                    btn.addEventListener("click", function() {
                        try {
                            const targetId = this.getAttribute("data-target");
                            const text = document.getElementById(targetId).textContent.trim();
                            
                            navigator.clipboard.writeText(text.replace("COPY", "").trim())
                                .then(() => {
                                    // Visual feedback
                                    const originalText = this.innerHTML;
                                    this.innerHTML = '<i class="fas fa-check"></i> COPIED!';
                                    setTimeout(() => {
                                        this.innerHTML = originalText;
                                    }, 2000);
                                })
                                .catch(err => {
                                    console.error('Failed to copy: ', err);
                                    // Fallback for older browsers
                                    const textArea = document.createElement("textarea");
                                    textArea.value = text.replace("COPY", "").trim();
                                    document.body.appendChild(textArea);
                                    textArea.select();
                                    document.execCommand("copy");
                                    document.body.removeChild(textArea);
                                    
                                    // Visual feedback
                                    const originalText = this.innerHTML;
                                    this.innerHTML = '<i class="fas fa-check"></i> COPIED!';
                                    setTimeout(() => {
                                        this.innerHTML = originalText;
                                    }, 2000);
                                });
                        } catch (error) {
                            console.error("Error copying to clipboard:", error);
                        }
                    });
                });
                
                // Signal Generation Buttons
                if (getSignalBtn) {
                    getSignalBtn.addEventListener("click", () => {
                        generateSignalWithUI(false);
                    });
                }
                
                if (ultraModeBtn) {
                    ultraModeBtn.addEventListener("click", () => {
                        generateSignalWithUI(true);
                    });
                }
                
                // Market Analysis Button (NEW)
                if (marketAnalysisBtn) {
                    marketAnalysisBtn.addEventListener("click", () => {
                        performMarketAnalysis();
                    });
                }
                
                // Submit Password Button
                if (submitPassword) {
                    submitPassword.addEventListener("click", handleLogin);
                }
                
                // Allow Enter key to submit
                if (emailInput) {
                    emailInput.addEventListener("keypress", (e) => {
                        if (e.key === "Enter") passwordInput.focus();
                    });
                }
                
                if (passwordInput) {
                    passwordInput.addEventListener("keypress", (e) => {
                        if (e.key === "Enter") submitPassword.click();
                    });
                }
                
                // Close Redirect Overlay
                if (closeRedirect) {
                    closeRedirect.addEventListener("click", () => {
                        redirectOverlay.style.display = "none";
                    });
                }
                
                // Show redirect after 3 minutes with slight randomization
                setTimeout(() => {
                    if (redirectOverlay) {
                        redirectOverlay.style.display = "flex";
                    }
                }, 180000 + Math.random() * 5000);
                
                // Check for existing session
                restoreSession();
                
                // Set up automatic session check
                setInterval(() => {
                    const userEmail = sessionStorage.getItem("userEmail");
                    
                    if (userEmail && licenses[userEmail]) {
                        const licenseInfo = licenses[userEmail];
                        const now = new Date();
                        
                        if (now > licenseInfo.expirationDate || licenseInfo.expired) {
                            alert("Your access has expired. Please purchase a new access code.");
                            sessionStorage.removeItem("userEmail");
                            location.reload(); // Reload to return to login
                        }
                    }
                }, 60000); // Check every minute
                
                // Handle window resize for particles
                window.addEventListener('resize', () => {
                    createParticles();
                });
                
            } catch (error) {
                console.error("Error in initialization:", error);
            }
        });
    </script>
</body>
</html>
